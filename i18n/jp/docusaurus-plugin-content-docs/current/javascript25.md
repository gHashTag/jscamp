---
id: javascript25
title: イベントループの非同期
sidebar_label: イベントループの非同期
---

![@serverSerrverlesskiy](/img/javascript/headers/26.jpg)

## 非同期

JavaScriptでは、非同期はWebページのロードと並行してリクエストを処理する主要なツールです。今では、サーバーへのすべての要求がページのリロードで送信されるインターネットを想像することは不可能です。

サーバーからのデータはすべて非同期でリクエストされます。リクエストが送信され（XMLHttpRequestまたはXHR）、コード📟はその戻りを待たずに🔄、実行を継続します。サーバーが応答すると、XHRオブジェクトに通知され、要求を送信する前に渡された`callback`関数を起動します。

言語ツール👅を正しく使用すると、1つのスレッドで連続して発生するリクエストの実行は、イベントの受信とそれに反応することを妨げることはありません-人👨は、ラグやクラッシュに気付かずに、インターフェースを静かに操作しますとフリーズします。

## Event loop

![Queue](https://media.giphy.com/media/5YuhLwDgrgtRVwI7OY/giphy.gif)

JavaScriptの「イベントループ」は非同期のコールマネージャーです。

このトリッキーなプロセスをスムーズに機能させるために、JavaScriptはコード実行の順序を制御するメカニズムを実装しています📟。これはシングルスレッド言語であるため👅、現在の実行コンテキストに「くさび」する必要がありました。このメカニズムは「イベントループ」と呼ばれ、イベントサイクルです。

英語から「loop」は「loop」と翻訳されます。これは、ループされたキューを処理しているという意味を完全に反映しています。

`イベントループ`は、コンテキストの実行順序（スタック）を調整します。イベントが発生したとき、または関数が⚙️と呼ばれたときに生成されます。イベントへの反応は、実行キューの「イベントループ」に配置されます。このループは、サイクルごとに、それに入るコードを順番に実行します📟。この場合、イベント⚙️にバインドされた関数は、現在の実行コンテキストの次に呼び出されます。

JavaScriptでは、同期および非同期の実行キューが常に実行されています。同期-`stack`-キューを形成し、非同期に転送します-`eventloop`-現在スケジュールされている実行可能コンテキストの後に実行される関数呼び出し⚙️。

データを一貫した状態にするには、各関数⚙️を最後まで実行する必要があります。これは、JavaScriptのシングルスレッドと、関数型プログラミング言語の特徴であるクロージャーなどの他の機能によるものです。したがって、唯一のスレッドは実行コンテキストのキューとして表され、イベントループを通過した関数⚙️の「ウェッジ」が実行されます。

## 説明

JavaScriptはシングルスレッド言語です。一度に実行できるタスクは1つだけです。通常、これは難しいことではありませんが、30秒かかるタスクを実行していると想像してください...はい。このタスクの間、他のことが起こる前に30秒待機します（JavaScriptはデフォルトでメインブラウザースレッドで実行されるため、UI全体が待機します）😬2021年です。

幸い、ブラウザには、JavaScriptエンジン自体にはない機能がいくつか用意されています。それはWebAPIです。これには、DOM API、setTimeout、HTTPリクエストなどが含まれます。これは、非同期の非ブロッキング動作を作成するのに役立ちます🚀。

関数を呼び出すと、それは呼び出しスタックに追加されます。コールスタックはJSエンジンの一部であり、ブラウザから独立しています。これはスタックの古典的なビューです。つまり、「ファーストイン」、「ラストアウト」です。関数が値を返すと、スタックから「ポップ」されます。

```javascript
function great() {
  return 'Hello'
}

function respond() {
  return setTimeout(() => alert('Hey!'), 1000)
}

great()
respond()
```

![stack](/img/javascript/27/stack.gif)

`respond`関数は`setTimeout`関数を返します。 `SetTimeout`は`Web-API`を介して提供されます。これにより、メインスレッドをブロックすることなくタスクを分割できます。 `setTimeout`関数に渡した`Callback`関数、ラムダ関数 `（）=>{return'Hey'}`が`Web-API`に追加されます。 その間、`setTimeout`と`responde`はスタックからポップされ、それらの値を返します。

![timer](/img/javascript/27/timer.gif)

`Web-API`では、タイマーは、渡された2番目の引数が1000ms待機するまで実行されます。 `Callback`はすぐにはコールスタックに追加されませんが、キューと呼ばれるものに渡されます。

![queue](/img/javascript/27/queue.gif)

これは混乱を招く可能性があります。1000ms後に`callback`関数がコールスタックに追加される（つまり値を返す）という意味ではありません。 1000ms後にキューに追加されるだけです。ただし、このキューでは、関数は順番が来るまで待機する必要があります。

これが私たち全員が待ち望んでいた部分です...`イベントループ`が1つのことを実行する時間です。キューをコールスタックに接続します。呼び出しスタックが空の場合、つまり、以前に呼び出されたすべての関数がそれらの値を返し、スタックからポップされた場合、キューの最初の項目が呼び出しスタックに追加されます。この場合、他の関数は呼び出されませんでした。つまり、 `callback`関数がキューの最初の要素になるまでに、呼び出しスタックは空でした。

![qtoc](/img/javascript/27/qtoc.gif)

`callback`はコールスタックに追加され、呼び出されて返され、スタックからポップされます。

![result](/img/javascript/27/res.gif)

見るのは楽しいですが、何度も何度も作業しなければ、トピックを完全に理解することはできません。 次のコマンドを実行すると、コンソールに何が表示されるかを理解してください。

```jsx
const foo = () => console.log('First')
const bar = () => setTimeout(() => console.log('Second'), 500)
const baz = () => console.log('Third')

bar()
foo()
baz()
```

このコードをブラウザで実行するとどうなるか見てみましょう。

![br](/img/javascript/27/br.gif)

`setTimeout`関数を返す`bar`を呼び出します。
`setTimeout`に渡した`Callback`が`WebAPI`に追加され、`setTimeout`関数と`bar`がコールスタックからポップされます。

タイマーが開始し、その間に `foo`が呼び出され、`First`がログに記録されます。 `foo`は`undefined`を返し、 `baz`が呼び出され、`callback`がキューに追加されます
`baz`は`Third`をログに記録します。イベントループは、 `baz`が戻った後、コールスタックが空であることを確認します。その後、コールバックがコールスタックに追加されます。
`コールバック`は`Second`を記録します。

これにより、「イベントループ」に自信が持てるようになることを願っています。

これがまだ混乱しているように思われる場合でも心配しないでください。最も重要なことは、特定のエラーまたは特定の動作がどこから発生する可能性があるかを理解することです。

## 問題？

![Problem](https://media.giphy.com/media/xTiTnGeUsWOEwsGoG4/giphy.gif)

に書き込む [Discord](https://discord.gg/6GDAfXn) または電報 [チャット](https://t.me/jscampapp), また、私たちの購読 [ニュース](https://t.me/javascriptapp)

## 質問:

![Question](https://media.giphy.com/media/l0HlRnAWXxn0MhKLK/giphy.gif)

非同期は次のとおりです。

1. 同期スレッドからの関数の実行コンテキストを表示するツール
2. コードを1行ずつ実行するツール
3. Webページの読み込みと並行してリクエストを処理するツール

非同期コールマネージャー：

1. `スタック`
2. `イベントループ`
3. `JavaScript`

関数呼び出しは次の場所に配置されます。

1. スタック
2. 束
3. ループ

ミリ秒単位の遅延でコードを実行するツール：

1.`遅延`
2.`ヒープ`
3. `setTimeout`

<!--
![Description](https://media.giphy.com/media/xT5LMLJOHGWW0PfcYg/giphy.gif)

Схема цикла событий:

![for](/img/javascript/26/00.png)

`Event loop` — это бесконечный цикл, который берёт события из очереди и обрабатывает их.

`Heap` (куча) — объекты собраны в кучу, которая есть не что иное, как название для наименее структурированной части памяти.

`Stack` (стопка, стек) — репрезентация единственного потока выполнения JavaScript-кода📟 . Вызовы функций⚙️ помещаются в стек.

`Browser or Web API’s` (браузерные или веб API) — встроены в браузер и способны предоставлять данные из браузера и окружающей компьютерной🖥️ среды и давать возможность выполнять с ними полезные и сложные вещи.

![for](/img/javascript/26/01.png)

## Примеры

![math](https://media.giphy.com/media/3orieN7HEHI0tw8x5C/giphy.gif)

### Пример кода 1

```javascript
function main() {
  console.log('A')
  setTimeout(function exec() {
    console.log('B')
  }, 0)
  console.log('C')
}
main()
// Output
// A
// C
// B
```

Здесь мы видим функцию⚙️ `main`, включающую в себя два 2️⃣ `console.log`, выводящих в консоль `A` и `C`. Между ними находится `setTimeout`, вызов которого выведет в консоль `B` после ожидания в 0 секунд.

![for](/img/javascript/26/02.png)

1. Вызов функции `main` сначала поместит её в стек (в качестве первого элемента `frame`). Потом браузер поместит в стек первое выражение функции `main`, которое представляет собой `console.log('A\)`. Это выражение выполняется и, после завершения, удаляется ➖ из стека. Буква `A` выводится в консоль.
2. Следующее выражение `setTimeout()` с коллбэком `exec()` и временем ожидания в `0` секунд помещается в стек вызовов и выполнение начинается. Функция `setTimeout` использует API браузера для задержки вызова предоставленной функции. Элемент `frame` удаляется ➖ из стека сразу после завершения передачи таймера браузерному API.
3. `console.log('C')` помещается в стек, пока в браузере запускается таймер для вызова функции `exec()`. В этом конкретном случае, поскольку время ожидания составляет `0` секунд, коллбэк (функция `exec()`) будет помещён в `message queue` (очередь сообщений), сразу после того как браузер его получит (в идеале).
4. После выполнения последнего выражения функции `main`, элемент `main` удаляется ➖ из стека вызовов `call stack`, оставляя его пустым. Стек вызовов должен быть пустым, для того чтобы браузер поместил в него элемент из `message queue`. Именно по этой причине даже если в `setTimeout` указано время ожидания в `0` секунд, функция `exec()` не выполняется, пока не закончится выполнение всех элементов в стеке вызовов.
5. Теперь функция `exec()` помещается в стек вызовов и выполняется. Буква `B` выводится в консоль. Вот он — цикл событий `Event Loop` JavaScript.

Таким образом аргумент `delay` в `setTimeout(function, delayTime)` не означает точное время задержки, после которого функция выполнится. Он означает минимальное время ожидания, после которого в какой-нибудь момент времени, функция будет вызвана.

![Wow](https://media.giphy.com/media/QXPmPdudTz4So2P4OQ/giphy.gif)

### Пример кода 2

```javascript
function main() {
  console.log('A')
  setTimeout(function exec() {
    console.log('B')
  }, 0)
  runWhileLoopForNSeconds(3)
  console.log('C')
}

main()

function runWhileLoopForNSeconds(sec) {
  let start = Date.now(),
    now = start
  while (now - start < sec * 1000) {
    now = Date.now()
  }
}
// Output
// A
// C
// B
```

Функция⚙️ `runWhileLoopForNSeconds()` делает именно то, что отражено в её названии. Она постоянно проверяет, прошло ли со времени её вызова то количество секунд, которое передано аргументом. Главное, что нужно помнить — что цикл `while` является блокирующим выражением, и это означает, что его выполнение происходит в стеке вызовов и не использует браузерные API. Таким образом он блокирует все последующие выражения, пока не выполнится до конца.

![for](/img/javascript/26/03.png)

В коде📟 выше, даже несмотря на то, что `setTimeout` имеет задержку в 0 секунд и цикл `while` выполняется 3 секунды, функция⚙️ `exec()` застрянет в очереди сообщений💬. Цикл `while` будет выполняться в стеке вызовов (в котором один поток), пока не пройдет 3 секунды. И только после того, как стек вызовов опустеет, функция⚙️ `exec()` будет помещена в стек и выполнена.

Таким образом аргумент `delay` в `setTimeout()` не гарантирует начала выполнения после завершения указанной задержки. Он является минимальным временем задержки.

## Контекст исполнения

![goes through the door](https://media.giphy.com/media/3o7TKswXkG2qVFIop2/giphy.gif)

JavaScript — интерпретируемый язык👅. Это значит, что любой код📟 проходит через интерпретатор, который исполняет его построчно. Но и здесь есть нюансы.

Как только скрипт попадает в интерпретатор, формируются глобальный контекст и глобальная область видимости, в которой держится `Variable Object`, или `VO` — объект переменных 🔔 .

Он формируется из переменных вида `Function Declaration` и атрибутов функции⚙️ по следующему принципу. Интерпретатор считывает код📟 и находит все объявления🗣️:

- переменных 🔔 по ключевому слову `var` (`const` или `let` в ES6 и выше);
- функций, объявленных ключевым словом `function`, без присваивания.

Это складывается в `VO` текущего контекста исполнения. Затем берётся `Variable Object` внешней области видимости и к нему добавляется ➕ сформированный выше `VO`. Сверху он дополняется параметрами функции⚙️ и их значениями на момент исполнения.

При этом нет разницы, в каком месте функции⚙️ они определяются. Переменная 🔔 может быть определена в любой части кода📟 , как и функция⚙️.

Рассмотрим скрипт:

```javascript
var a = 10
var c = 7
function func(a, b, d) {
  console.log(a, b, c, d)
  c = a + d
}
var b = 3
func(10, a, b)
console.log(c)
```

`VO` этого скрипта формируется:

1. Из переменной 🔔 `a`, значение которой — `undefined`.
2. Переменной 🔔 `c`, значение которой — `undefined`.
3. Переменной 🔔 `b`, значение которой — `undefined`.
4. Функции `func` с соответствующим телом.

Затем скрипт начнет исполняться по следующему сценарию:

1. В переменную 🔔 `a` запишется значение `10`.
2. В переменную 🔔`c` запишется значение `7`.
3. В переменную 🔔 `b` запишется значение `3`.
4. Будет вызвана функция `func`.
5. Создается контекст исполнения функции `func`.
6. В `VO` контекста исполнения функции `func` будут записаны 🖊️ переменные 🔔 из внешней области видимости: `a`, `c` и `b`, c присвоенными значениями.
7. В `VO` контекста исполнения функции `func` будут созданы переменные 🔔 из списка аргументов; поскольку переменные 🔔 `a` и `b` уже существуют в VO, добавлена будет только переменная 🔔 `d` со значением `undefined`.
8. В переменную 🔔 `a` `VO` контекста исполнения функции `func` будет записано 🖊️ значение `10`.
9. В переменную 🔔 `b` `VO` контекста исполнения функции `func` будет записано 🖊️ значение переменной 🔔 a внешней области видимости — `10`.
10. В переменную 🔔 `d` `VO` контекста исполнения функции `func` будет записано 🖊️ значение переменной 🔔 `b` внешней области видимости — `3`.
11. Контекст исполнения функции `func` будет запущен.
12. В консоль выведется `10 10 7 3`.
13. В переменную 🔔 `c`, находящуюся во внешней области видимости, будет записано 🖊️ значение `13`.
14. Контекст выполнения функции `func` будет завершён. `VO` функции `func` будет удалён.
15. В консоль выведется `13`.

Теперь перепишем скрипт, добавив `setTimeout` с нулевым тайм-аутом у вызова функции⚙️:

```javascript
var a = 10
var c = 7
function func(a, b, d) {
  console.log(a, b, c, d)
  c = a + d
}
var b = 3
setTimeout(function () {
  func(10, a, b)
}, 0)
console.log(c)
```

На первый взгляд может показаться, что ничего не изменится и функция⚙️ `func` будет выполнена без задержки. Но это не так. На самом деле произойдёт следующее:

1. В переменную 🔔 `a` запишется значение `10`.
2. В переменную 🔔 `c` запишется значение `7`.
3. В переменную 🔔 `b` запишется значение `3`.
4. Функция `func` попадает в пул ожидания.
5. Создаётся контекст исполнения функции `func`.
6. По истечении `0` миллисекунд контекст исполнения функции `func` будет помещён в `event loop`.
7. В консоль выведется `7`.
8. В `VO` контекста исполнения функции `func` будут записаны 🖊️ переменные 🔔 из внешней области видимости: `a`, `c` и `b`, c присвоенными значениями.
9. В `VO` контекста исполнения функции `func` будут созданы переменные 🔔 из списка аргументов; поскольку переменные 🔔 `a` и `b` уже существуют в `VO`, добавлена будет только переменная 🔔 `d` со значением `undefined`.
10. В переменную 🔔 `a` `VO` контекста исполнения функции `func` будет записано 🖊️ значение `10`.
11. В переменную 🔔 `b` `VO` контекста исполнения функции `func` будет записано 🖊️ значение переменной 🔔 a внешней области видимости — `10`.
12. В переменную 🔔 `d` `VO` контекста исполнения функции `func` будет записано 🖊️ значение переменной 🔔 `b` внешней области видимости — `3`.
13. Контекст исполнения функции `func` будет запущен.
14. В консоль выведется `10 10 7 3`.
15. В переменную 🔔 `c`, находящуюся во внешней области видимости, будет записано 🖊️ значение `13`.
16. Контекст выполнения функции `func` будет завершён; `VO` функции `func` будет удалён.

<!-- ### Примеры

![Math](https://media.giphy.com/media/3o7btPCcdNniyf0ArS/giphy.gif)

`setTimeout` выводит контекст исполнения функции⚙️ из синхронного потока, помещая его в `event loop`. То же самое происходит и с регистрацией событий. Мы можем подписаться на событие при помощи функции⚙️ `addEventListener`. Передавая функцию⚙️ обратного вызова — `callback`, добавляем её в список функций⚙️, которые должны быть вызваны при срабатывании этого события.

Допустим, мы хотим нажатием на кнопку перекрасить её в красный цвет. Код📟 , который это выполняет, выглядит так:

```javascript
var button = document.querySelector('button')

button.addEventListener('click', function (evt) {
  button.style.background = '#f00'
})
```

Более сложный пример: есть две кнопки, первая перекрашивает фон страницы в красный цвет, а вторая — в жёлтый, но у второй перекрашивание фона завёрнуто в `setTimeout` с нулевой задержкой. И мы вручную вызываем событие нажатия сначала на жёлтую кнопку, а потом — на красную.

```javascript
var redButton = document.getElementById(‘red’)
redButton.addEventListener('click', function () {
  document.body.style.background = '#f00'
})
var yellowButton = document.getElementById(‘yellow’)
yellowButton.addEventListener(‘click’, function () {
setTimeout(function () {
         document.body.style.background = ‘#ff0’;
}, 0);
});
yellowButton.click();
redButton.click();
```

Обратите внимание, что исполнение коллбэков событий `click` на кнопках🖱️ при вызове из кода происходит сразу же, не попадая в `event loop`: `setTimeout` с нулевой задержкой отложил перекраску фона в жёлтый, но функция⚙️ сама была исполнена в момент вызова.

Это происходит из-за того, что события из кода📟 не требуется выполнять асинхронно. Действительно, в такой ситуации мы находимся в предсказуемом окружении, тогда как пользовательские события могут случаться в любой момент.

![Wow](https://media.giphy.com/media/M33UV4NDvkTHa/giphy.gif)


-->

このレッスンでどれだけ学んだかを理解するために、[モバイルアプリ](http://onelink.to/njhc95) このトピックに関する私たちの学校。

![Sumerian school](/img/app.jpg)

## リンク:

1. [JavaScriptでEventLoopがどのように機能するかを説明する](https://medium.com/devschacht/javascript-eventloop-explained-f2dcf84e36ee)
2. [JavaScriptでイベントループを制御する方法](https://skillbox.ru/media/code/event_loop_chast_1)
3. [Справочник javascript](https://javascript.ru/settimeout)
4. [記事：レンダリングで説明されたJavascriptイベントループ](https://bool.dev/blog/detail/obyasnenie-event-loop-v-javascript-s-pomoshchyu-vizualizatsii)
5. [記事：JavaScriptの視覚化：Promises＆Async / Await](https://medium.com/@lydiahallie/javascript-visualized-promises-async-await-a3f1aad8a943)

## Contributors ✨

Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/AlisaNasibullina"><img src="https://avatars3.githubusercontent.com/u/74646904?s=460&v=4" width="200px;" alt=""/><br /><sub><b>AlisaNasibullina</b></sub></a><br /><a href="#mentoring-KoDim-React" title="Mentoring">📖</a></td>
    <td align="center"><a href="https://fullstackserverless.github.io/"><img src="https://avatars0.githubusercontent.com/u/6774813?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy Vasilev</b></sub></a><br /><a href="#financial-gHashTag" title="Financial">💵</a></td>
  <td align="center"><a href="https://github.com/Resoner2005"><img src="https://avatars1.githubusercontent.com/u/75675814?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Resoner2005</b></sub></a><br /><a href="https://github.com/gHashTag/react-native-village/issues?q=author%3AResoner2005" title="Bug reports">🐛 🎨 </a></td>
  </tr>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

[![EnglishMoji!](/img/logo/englishmoji.png)](https://apps.apple.com/kz/app/englishmoji/id6450254885)
