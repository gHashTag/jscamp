---
id: javascript16
title: サイクル
sidebar_label: サイクル
---

![@serverSerrverlesskiy](/img/javascript/headers/17.jpg)

アクションを何度も繰り返す必要がある場合、プログラミングではサイクルが使用されます。たとえば、テキストを画面に200回表示する必要があります  «Hello, World!»  . 同じテキスト出力コマンドを200回繰り返す代わりに、ループの本体に書かれているを200回繰り返すループが作成されることがよくあります。各繰り返しは反復と呼ばれます。

![cycle](https://media.giphy.com/media/Pkck2unt0XQfc4gs3R/giphy.gif)

プログラミングの反復（広義には）は、（再帰ではなく）呼び出し自体につながることなく、アクションが何度も繰り返されるデータ処理の編成です。狭義には、反復的で循環的なプロセスの1つのステップです。

サイクルイン JavaScript (そして他のすべての言語では ）はコードのブロックですこれは、既知の条件が真である限り繰り返されます。ループにはさまざまな種類がありますが、基本的に同じことを行います。アクションを数回繰り返します。

## サイクル while()

![While](https://media.giphy.com/media/WS6CDvvyNDrhZRFBtT/giphy.gif)

オペレーター `while` テストされる条件が真である間、指定された命令を実行するループを作成します。条件の論理値は、ループ本体の実行前に計算されます。

### 構文

![Boock](https://media.giphy.com/media/LkjlH3rVETgsg/giphy.gif)

```javascript
while (調子) {
  命令 // アルゴリズムコード-命令
}
```

`調子` - ループに入る前に毎回ブール値がチェックされる式。値がtrueの場合 - `true` , その後、命令が実行されます。値がfalseになったとき - `false` , ループを終了します.

`命令` - これは、条件が真になるたびに実行されるアルゴリズムのコードです。ループ内で複数の命令を実行するには、ブロック❌演算子を使用します `{ ... }` それらをグループ化します。ループの本体で1つのコマンドを使用する場合、中括弧は省略できます.

これがループの最も簡単な例です `while(調子) {...}`

```jsx live
function learnJavaScript() {
  let count = 0 // count - カウンター
  let result = 'Счет: '
  // アカウントを任意に変更します
  while (count < 10) {
    result += count + ', '
    count++
  }

  return result
}
```

カウンター `count` 例ではそれが重要です `0`. ループの条件（角かっこで囲まれています）は、コードを含むブロックが（つまり、実際には）まで何度も繰り返されることです。 `while`) `count` もっと少なく `10`.

初期値以降 `0` もっと少なく `10`, コードが実行されます。条件がまだ真である場合、インタープリターが✔заново条件を再チェックするたびに `true`  , その後、コードが再度実行されます。カウンター値を増やすたびに `1`. それ以外の場合、値は次のようになります。 `0`, なぜ私たちの状態ですか `カウンター < 10` 常に真のままであり、コードは永久にループします!

その結果、 `10` サイクル、それは等しくなります `10`. その後、通訳は条件としてループを終了します `false`  コードの最後の行に移動します。

## サイクル for ()

![Create](https://media.giphy.com/media/XaExByjWTK1V2HgDfh/giphy.gif)

式 `for` セミコロンで区切られた括弧内の3つの3️⃣オプション式のループを作成します。

### 構文

![Book](https://media.giphy.com/media/l1J9HWBKLp20YfNAY/giphy.gif)

```javascript
for ([初期化]; [調子]; [最終式])
  { 式 }
```

`初期化` - 変数の式または定義。この式は、オプションでキーワードを使用して新しい変数を宣言できます `let`. これらの変数はループ内でのみ表示されます `for`, それら。同じ範囲内（安全のため）).

`調子` - ループの各反復で実行される式。式がtrueの場合、ループが実行されます。条件はオプションです。そうでない場合、条件は常に真と見なされます。式がfalseの場合、実行 `for` 終了します.

`最終式` - ループ反復の最後に実行される式。次の条件が満たされるまで発生します。通常、 `増加する++`, `減少--` または `リニューアル i += 5` 変数カウンター.

`式` - ループ状態になるまでのアルゴリズムの実行可能コード `本当に`. ループ内で複数の式を実行するには、ブロックを使用します `{ ... }` これらの式をグループ化します。ループ内で式を実行しない場合は、空の式を使用します `for (;;;)`.

から数の合計を計算しましょう 0 前 100  :

```jsx live
function learnJavaScript() {
  let sum = 0
  for (let i = 0; i <= 100; i++) {
    sum += i
  }

  return sum
}
```

最初に1️⃣を書いたときのことを覚えておいてください `while( )`, 私たちのカウンターはどうなりましたか？彼が絶えず変化することが非常に重要であることがわかりました（これは私たちを助けました `インクリメント ++`). なぜなら、これを忘れると、コードが `サイクルの無限のループ `。

まあ、このような状況はかなり定期的に発生します `while‑サイクル`, それが理由です `for` 内蔵カウンターで！

### ループの例 for

![hmm](https://media.giphy.com/media/l3nSILUHhuVDuWSnC/giphy.gif)

初めて構文を見る   `サイクル for`, あなたは🤔これは非常に奇妙なことだと思うかもしれません。しかし、あなたはそれを勉強する必要があります🎓あなたが会うので
このように何度も：

```jsx live
function learnJavaScript() {
  let result = 'スコア: '

  for (let i = 0; i < 10; i++) {
    result += i + ' '
  }

  return result
}
```

![Wow](https://media.giphy.com/media/3oriO13KTkzPwTykp2/giphy.gif)

さて、あなたは知っていましたか？しかし、彼らは持っているべきです！結局のところ、これは私たちが使用したのと実質的に同じコードです `while` 章の始めでループしてください！サイクルの3つの部分は、セミコロンで互いに区切られています。それらはすべてそのサイクルにありました `while`, しかし、他の場所で。よく見てみましょう:

![for](/img/javascript/14/00.png)

1. まず、カウンター変数を宣言します  `let i = 0`. これは関数自体の中にあり、このサイクルの外にあります `i` 不在になります、そしてそれは安全です！
2. 次に、ループの各反復の前にインタープリターがチェックする条件を設定します（新しいコードからコードを開始する価値があるかどうかを判断するため）。反復は、ループの1回の反復と呼ばれます（たとえば、起動サイクルが10回あった場合、コードの反復は10回あったと言えます）。
3. コードの3番目の部分は `インクリメント ++` (または `デクリメント --`). 各反復の最後に実行され、毎回変数を変更します。

## 結論

![The and](https://media.giphy.com/media/l1Lc1Kn9hImgpx5Re/giphy.gif)

ほとんどの場合、必要な反復回数がわかっていると、次の作業を行う可能性が高くなります。 `for`, ではなく `while`. この点で、サイクル `for` とても人気があります。他のサイクルもありますが、あまり人気がなく、必要に応じて知ることができます。 [ここに](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/%D0%A6%D0%B8%D0%BA%D0%BB%D1%8B_%D0%B8_%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8).

## 問題?

![Problem](https://media.giphy.com/media/xTiTnGeUsWOEwsGoG4/giphy.gif)

に書く [Discord](https://discord.gg/6GDAfXn) または電報 [チャット](https://t.me/neuro_coder_group), また、私たちの購読 [ニュース](https://t.me/javascriptapp)

## 質問と回答:

![Question](https://media.giphy.com/media/l0HlRnAWXxn0MhKLK/giphy.gif)

特定の条件が真でなくなるまで何度も繰り返されるコードのブロックの名前は何ですか？

1. サイクル
2. 状態
3. 初期化

2つのループ演算子のどちらがより人気がありますか？

1. `for`
2. `while`
3. `break`

次のコードはコンソールにいくつのメッセージを出力しますか？

```javascript
let k = 0
while (k < 7) {
  console.log('もう1行!')
}
```

1. `7`
2. `8`
3. `無限に`

括弧内のサイクルの部分を互いに分離するために使用される文字 for?

1. `&&`
2. `;`
3. `=!`

もし `_______` 常に真のままであると、コードが無限にスタックする可能性があります `_______`.

1. 条件/ループ
2.サイクル/状態

平均の名前は何ですか `_____` ループの3つの括弧で囲まれた部分の `for`?

1. 式
2.状態
3.インクリメント

次のコードはコンソールにいくつのメッセージを出力しますか？

```javascript
const maxNumer = 17
let n = 0
while (n <= maxNumer) {
  console.log('数えてみよう! ' + n)
  n = n + 2
}
```

1. `8`
2. `9`
3. `10`

サイクルの1回（ステップ）の経過を表す用語は何ですか？

1. 反復
2. 割り込み
3. ループ

このレッスンをどれだけ学んだかを理解するために、でテストを受けてください [モバイルアプリ](http://onelink.to/njhc95) このトピックに関する私たちの学校。

![Sumerian school](/img/app.jpg)

## リンク:

1. [MDN web doc. 論文 "サイクル do...while"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/do...while)
2. [MDN web doc. 論文 "サイクル for"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for)
3. [MDN web doc. 論文 "サイクル while"](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/while)
4. [論文 "Iteration", 論文 Javascript Express](https://www.javascript.express/syntax/iteration)
5. [論文 "サイクル while そして for"](https://learn.javascript.ru/while-for)
6. [十代の若者たちのためのコード：プログラミングの完璧な初心者向けガイド、ボリューム 1: Javascript - Jeremy Moritz ](https://www.amazon.com/Code-Teens-Beginners-Programming-Javascript-ebook/dp/B07FCTLVPC)

## Contributors ✨

Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/KoDim-React"><img src="https://avatars1.githubusercontent.com/u/72087863?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy K.</b></sub></a><br /><a href="#mentoring-KoDim-React" title="Mentoring">  </a></td>
    <td align="center"><a href="https://fullstackserverless.github.io/"><img src="https://avatars0.githubusercontent.com/u/6774813?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy Vasilev</b></sub></a><br /><a href="#financial-gHashTag" title="Financial">💵</a></td>
    <td align="center"><a href="https://github.com/Resoner2005"><img src="https://avatars1.githubusercontent.com/u/75675814?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Resoner2005</b></sub></a><br /><a href="https://github.com/gHashTag/react-native-village/issues?q=author%3AResoner2005" title="Bug reports">🐛 🎨 🖋</a></td>
    <td align="center"><a href="https://github.com/Navernoss"><img src="https://avatars0.githubusercontent.com/u/75784137?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Navernoss</b></sub></a><br /><a href="#content-Navernoss" title="Content">🖋 🐛 🎨 </a></td>
  </tr>
  
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

[![EnglishMoji!](/img/logo/NeuroCoder.png)](https://vk.com/neurocoder)

<!--

### Жизненный цикл

Рассмотрим пример цикла `while` из реальной жизни.
Предположим, вы — трёхлетний малыш (вам же когда‑то было три, так ведь?). Всё утро вы с упоением играли в конструктор, но тут пришла мама и сказала, что пора заканчивать, а все кубики нужно собрать в коробку. А их тут на полу несметные сотни! Вы быстро прикидываете в уме и понимаете, что за раз вам с этим никак не управиться. Так что вы приходите к единственному разумному решению в такой ситуации: начинаете плакать. И тут ваша мама поражает вас до глубины души, предлагая простое решение, казалось бы, неразрешимой проблемы: она берёт сначала часть кубиков, затем кладёт их в коробку, затем возвращается и… повторяет то же самое! И этот удивительный трюк нужно будет проделать столько раз, сколько потребуется, чтобы все кубики
с пола перекочевали в коробку.

Вы прикидываете в уме… Ну да, вроде всё верно! Должно сработать while()!

Давайте шаг за шагом разберём мамин план:

- Предположим, вы выяснили, что ваша `oneCube` - кубикоПодъёмность (то есть то, сколько кубиков за раз вы сможете унести) — постоянная величина (вы понимаете — константа) и равняется 10.
- Давайте также предположим, что `countCube` - кубиковНаПолу разбросано 120 штук.
- Инструкции таковы: взять наибольшее возможное количество кубиков с пола и перенести их в коробку (то есть вычесть нашу `кубикоПодъёмность` из `кубиковНаПолу`).
- Всё время, пока (то есть while) `кубикиНаПолу` ещё остаются (то есть пока наше условие остаётся истинным), нам предстоит возвращаться (то есть совершать цикл) к выполнению инструкции.

Вот вариант этого плана на языке JavaScript:

```jsx live
function learnJavaScript() {
  const oneCube = 10
  let countCube = 120
  console.log('На полу ' + countCube + ' кубиков.')
  while (countCube > 0) {
    // комбинированное присваивание: `x -= y;` то же, что и `x = x - y;`
    countCube = countCube - oneCube
    console.log('Я убрал в коробку ' + oneCube + ' кубиков, и теперь на полу осталось только ' + countCube + '.')
  }
  console.log('Ура-а-а! Все кубики уложены в коробку!')
}
```

```
На полу 120 кубиков.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 110.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 100.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 90.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 80.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 70.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 60.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 50.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 40.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 30.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 20.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 10.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 0.
 Ура-а-а! Все кубики уложены в коробку!
```

Надеюсь, тут всё понятно? И смотрите, какая занятная штука: всё то же самое вы можете проделать с любым количеством `countCube - кубиковНаПолу`, а количество необходимого для этого кода останется примерно тем же! Чтобы показать вам, насколько гибкими могут быть циклы, мы завернём наш код в `функцию с этим параметром`.

Итак, у нас должен выйти следующий рассказ созданный программой:

```jsx live
function learnJavaScript() {
  // oneCube - кубикоПодъёмность
  let oneCube = 10
  // countCube - кубиковНаПолу

  let clearing = function (countCube) {
    let result = 'На полу ' + countCube + ' кубиков. \n'

    while (countCube > 0) {
      countCube = countCube - oneCube
      result += 'Я убрал в коробку ' + oneCube + ' кубиков, и теперь на полу осталось только ' + countCube + '. \n'
    }

    result += '\n Ура-а-а! Все кубики уложены в коробку!'
    return result
  }

  return clearing(70)
}
```

Ну а теперь можно просто вызвать нашу функцию `clearing(70)` предложив ей другой аргумент, изменив наш рассказ!

### break

Чтобы организовать бесконечный цикл, используют конструкцию `while (true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.

:::note Внимание
Если условие явно не указывать, а оставить `while ()`, то считается что условие всегда будет `true`. И тут уж приходиться из цикла выходить используя команду `break`.
:::

### continue

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву `continue` переходя к следующему шагу цикла (итерации).

:::note Обратите внимание
Если вы случайно запустите «вечную петлю», то вам придётся перезапустить браузер Chrome и исправить код, чтобы продолжить работу.
:::

Например, цикл ниже использует continue, чтобы выводить только нечётные значения:

```jsx live
function learnJavaScript() {
  let result = ''
  for (let i = 0; i < 10; i++) {
    // если true, пропустить оставшуюся часть тела цикла
    if (i % 2 == 0) continue
    result += i + ' ' // 1 3 5 7 9
  }

  return result
}
```

Для чётных значений i, директива continue прекращает выполнение тела цикла и передаёт управление на следующую итерацию for (со следующим числом). Таким образом `result += i` вызывается только для `нечётных значений`.
### Просто «так принято»

А теперь вновь напем тот же код, но назовем переменную `i`, а не `счётчик`:

```javascript
let i = 0
while (i < 10) {
  console.log(i + ' ')
  i++
}
// console.log('0 1 2 3 4 5 6 7 8 9');
```

Так, ну и в чём же тут смысл? Неужели необходима была другая переменная?

Да нет. А зачем тогда всё это? Дело в том, что в названии `i` самом по себе, конечно, ничего особенного нет, но по условленной договорённости, если хотите, по традиции, переменную, которая циклично увеличивается или уменьшается,
принято называть именно так. Когда подобного рода решения принимаются не из соображений правильности или неправильности кода, но «по традиции», мы называем это соглашением о стандартах оформления кода.

Это именно способ исполнения соглашения. Возьмём в качестве примера `верблюжийРегистр`: ведь на работе кода, по сути, никак не скажется, если ваши переменные будут ВОТТАКИМИ, или воттакими, или вовсе вот_такими. Однако, следуя соглашению об использовании `верблюжьегоРегистра` ваш код с самого начала визуально по ходил на код профессиональных разработчиков, а им самим будет гораздо легче читать и понимать его.

Так вот, использование строчной `i` для циклично увеличивающейся (при помощи `инкремента ++`) или уменьшающейся (при помощи `декремента --`) переменной — это также стандарт оформления кода. Если вы решите продолжить карьеру в качестве профессионального разработчика, то переменную i в таких обстоятельствах вам предстоит лицезреть сотни и тысячи раз.

-->
<!-- ## Цикл for...in

Проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу.

### Синтаксис

```javascript
for (variable in object) { ...
}
```

`variable` - очередное (следующее) имя свойства назначается переменной на каждой итерации.

`object` - объект, по чьим свойствам мы проходим.

### Описание

Цикл `for...in` проходит только по перечисляемым свойствам объекта. -->

<!-- ### Удаление, добавление и модификация свойств

Цикл `for...in` проходит по свойствам в произвольном порядке.

Если свойство изменяется за одну итерацию, а затем изменяется снова, его значением в цикле является его последнее значение. Свойство, удаленное до того, как до него дошёл цикл, не будет участвовать в нём.

Свойства добавленные в объекты в цикле могут быть пропущены. В общем, лучше `не добавлять, изменять или удалять` свойство из объекта `во время итерации`, если по нему ещё не прошли. Нет гарантии, что добавленное свойство будет посещено циклом, изменное после проведения изменений, а удалённое после удаления.

### Проход по массиву и for...in

Индексы массива - это перечисляемые свойства с целочисленными именами, в остальном они аналогичны свойствам объектов. Нет гарантии, что `for...in` будет возвращать индексы в конкретном порядке. Цикл `for...in` возвращает все перечисляемые свойства, включая имеющие нецелочислиненные имена и наследуемые.

:::note Замечание
`for...in` не следует использовать для `Array`, где важен порядок индексов.
:::

Так как порядок прохода зависит от реализации, `проход по массиву` может не произойти в правильном порядке. Следовательно лучше `с числовыми индексами` использовать циклы for, Array.prototype.forEach() или for...of, когда проходим по массивам, где важен `порядок доступа к свойствам`.

### Проход только через собственные свойства

Следующее выражение берёт аргументом объект. Затем проходит по всем перечислимым свойствам объекта и возвращает строку содержащую имена свойств и их значения.

Нажмите в браузере Google Chrome сочетание клавиш `Ctrl + Shift + I` и на вкладке `Console` наберите:

```javascript
var obj = { a: 1, b: 2, c: 3 }

for (var i in obj) {
  console.log('obj.' + i + ' = ' + obj[i])
}

// Выведет:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
``` -->

<!--
## Цикл for ... of

Проходит по итерируемым объектам (включающим в себя массивы, массивоподобные объекты и итераторы с генераторами), выполняя пользовательский хук с инструкциями, исполняющимися для значения каждого уникального свойства.

### Сводка

Оператор `for...of` выполняет цикл обхода итерируемых объектов (включая `Array`, `Map`, `Set`, объект аргументов и подобных), вызывая на каждом шаге итерации операторы для каждого значения из различных свойств объекта.

### Синтаксис

```javascript
for (variable of iterable) {
  statement
}
```

`Variable` - на каждом шаге итерации variable присваивается значение нового свойства объекта iterable. Переменная variable может быть также объявлена с помощью const, let или var.

`Iterable` - объект, перечисляемые свойства которого обходятся во время выполнения цикла.

### Обход Array[..]

```jsx live
function learnJavaScript() {
  let result = ''
  let mas = [10, 20, 30]

  for (let value of mas) {
    value += 5
    result += value + ' '
  }

  return result
}
```

Можно также использовать `const` вместо `let`, если не нужно переназначать переменные внутри блока.

```jsx live
function learnJavaScript() {
  let result = ''
  let mas = [10, 20, 30]

  for (const value of mas) result += value + ' '

  // 10 20 30

  return result
}
```

:::note Внимание
В цикле `for()` выполняется всего одна команда, поэтому `фигурные скобки {...}` можно не писать.
:::

### Обход String

```jsx live
function learnJavaScript() {
  let result = ''
  let iterable = 'boo'

  for (let value of iterable) {
    result += value + ' '
  }
  // "b" "o" "o"

  return result
}
``` -->

<!--
### Обход TypedArray

```jsx live
function learnJavaScript() {
  let result = ''
  let iterable = new Uint8Array([0x04, 0x10, 0xff])

  for (let value of iterable) {
    result += value + ' '
  }
  // 4 16 255
  return result
}
``` -->

<!-- ```javascript
### Обход Map
let iterable = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
])

for (let entry of iterable) {
  console.log(entry)
}
// ['a', 1] ['b', 2] ['c', 3]

for (let [key, value] of iterable) {
  console.log(value)
}
// 1 2 3
```

### Обход Set

```javascript
let iterable = new Set([1, 1, 2, 2, 3, 3])

for (let value of iterable) {
  console.log(value)
}
// 1 2 3
```

### Обход объекта arguments

```javascript
;(function () {
  for (let argument of arguments) {
    console.log(argument)
  }
})(1, 2, 3)

// 1 2 3
```

### Закрытие итераторов

В циклах `for...of` аварийный выход осуществляется через `break`, `throw` или `return`. Во всех вариантах итератор завершается.

## Различия между for...in и for...of

:::note Разница
Оба оператора, и `for...in и for...of` производят обход объектов . Разница в том, как они это делают.
:::

Для `for...in` обход перечисляемых свойств объекта осуществляется в произвольном порядке.

Для `for...of` обход происходит в соответствии с тем, какой порядок определен в итерируемом объекте. -->
