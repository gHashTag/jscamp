---
id: javascript25
title: Асинхронность Event loop
sidebar_label: Асинхронность Event loop
---

import YouTube from 'react-youtube'

![@serverSerrverlesskiy](/img/javascript/headers/26.jpg)

## Асинхронность

В JavaScript асинхронность — основной инструмент, который обрабатывает запросы параллельно с загрузкой веб-страницы. Сейчас невозможно представить интернет, где все запросы на сервер отправлялись бы с перезагрузкой страницы.

Любые данные от сервера запрашиваются асинхронно: отправляется запрос (XMLHttpRequest или XHR), и код не ждёт его возвращения, продолжая выполняться. Когда же сервер отвечает, объект XHR получает уведомление об этом и запускает функцию⚙️ обратного вызова — `callback`, который передали в него перед отправкой запроса.

Если правильно использовать инструменты языка , то выполнение запроса, который происходит последовательно и в одном потоке, никак не мешает приёму событий и реакции на них — человек спокойно работает с интерфейсом, не замечая лагов, сбоев и зависаний.

## Видео

<YouTube videoId="vQbBNRyeshw" />

## Event loop

![Queue](https://media.giphy.com/media/5YuhLwDgrgtRVwI7OY/giphy.gif)

`Event loop` в JavaScript — менеджер асинхронных вызовов.

Чтобы этот хитрый процесс слаженно работал, в JavaScript реализован механизм для управления очерёдностью исполнения кода . Поскольку это однопоточный язык , возникла необходимость "вклиниваться" в текущий контекст исполнения. Этот механизм называется `event loop` — событийный цикл.

С английского `loop` переводится как "петля", что отлично отражает смысл: мы имеем дело с закольцованной очередью.

`Event loop` регулирует последовательность исполнения контекстов — стек. Он формируется, когда сработало событие или была вызвана функция⚙️. Реакция на событие помещается в очередь исполнения, в `event loop`, который последовательно, с каждым циклом выполняет попадающий в него код . При этом привязанная к событию функция⚙️ вызывается следующей после текущего контекста исполнения.

В JavaScript постоянно работают связанные между собой синхронная и асинхронная очереди выполнения. Синхронная — `stack` — формирует очередь и пробрасывает в асинхронную — `event loop` — вызовы функций⚙️, которые будут выполнены после текущего запланированного исполняемого контекста.

Чтобы данные находились в консистентном состоянии, каждая функция⚙️ должна быть выполнена до конца. Это обусловлено однопоточностью JavaScript и некоторыми другими особенностями, например характерными для функциональных ⚙️языков  программирования замыканиями. Поэтому единственный поток представлен в виде очереди контекстов исполнения, в которой и происходит "вклинивание" функций⚙️, прошедших через цикл событий.

## Описание

JavaScript это однопоточный язык: одновременно может выполняться только одна задача. Обычно в этом нет ничего сложного, но теперь представьте, что вы запускаете задачу, которая занимает 30 секунд... Да. Во время этой задачи мы ждем 30 секунд, прежде чем что-либо еще может произойти (по умолчанию JavaScript запускается в главном потоке браузера, поэтому весь пользовательский интерфейс будет ждать) Сейчас 2021 год, никто не хочет медленный сайт который тупит.

К счастью, браузер предоставляет нам некоторые функции, которые сам механизм JavaScript не предоставляет: Web API. Который включает в себя DOM API, setTimeout, HTTP-запросы и так далее. Это может помочь нам создать асинхронное неблокирующее поведение .

Когда мы вызываем функцию, она добавляется в call stack(стек вызовов). Стек вызовов является частью механизма JS, это не зависит от браузера. Это классический взгляд на стек, т.е `first in`, `last out`. Когда функция возвращает значение, она "выталкивается" из стека.

```javascript
function great() {
  return 'Hello'
}

function respond() {
  return setTimeout(() => alert('Hey!'), 1000)
}

great()
respond()
```

![stack](/img/javascript/27/stack.gif)

Функция `respond` возвращает функцию `setTimeout`. `SetTimeout` предоставляется нам через `Web-API`: он позволяет нам делить задачи, не блокируя основной поток. `Callback` функция, которую мы передали в функцию `setTimeout`, лямбда функция `() => {return 'Hey'}` добавляется в `Web-API`. Тем временем `setTimeout` и `responde` извлекаются из стека и возвращают свои значения.

![timer](/img/javascript/27/timer.gif)

В `Web-API` таймер работает до тех пор, пока второй аргумент, который мы передали ему, не подождет 1000 мс. `Callback` не сразу добавляется в стек вызовов, а передается в нечто, называемое очередью.

![queue](/img/javascript/27/queue.gif)

Это может сбивать с толку: это не означает, что `callback` функция добавляется в стек вызовов (таким образом, возвращает значение) через 1000 мс! Он просто добавляется в очередь через 1000 мс. Но в этой очереди, функция должна ждать пока придет ее черёд.

Теперь это та часть, которую мы все ждали... Время для `event loop` выполнить единственную задачу: соединить очередь со стеком вызовов! Если стек вызовов пуст, то есть, если все ранее вызванные функции вернули свои значения и были извлечены из стека, первый элемент в очереди добавляется в стек вызовов. В этом случае никакие другие функции не были вызваны, что означает, что стек вызовов был пуст к тому времени, когда `callback` функция была первым элементом в очереди.

![qtoc](/img/javascript/27/qtoc.gif)

`callback` добавляется в стек вызовов, вызывается и возвращает значение, а также извлекается из стека.

![result](/img/javascript/27/res.gif)

Смотреть весело, но вы не сможете полностью понять тему, не работая с ней снова и снова. Попробуйте выяснить, что появится в консоли, если мы запустим следующее:

```jsx
const foo = () => console.log('First')
const bar = () => setTimeout(() => console.log('Second'), 500)
const baz = () => console.log('Third')

bar()
foo()
baz()
```

Давайте посмотрим, что происходит, когда мы запускаем этот код в браузере:

![br](/img/javascript/27/br.gif)

Мы вызываем `bar`, которая возвращает функцию `setTimeout`.
`Callback` который мы передали в `setTimeout` добавляется в `Web API`, функция `setTimeout` и `bar` извлекаются из стека вызовов.

Таймер запускается, тем временем `foo` вызывается и записывает в журнал `First`. `foo` возвращает `undefined`, `baz` вызывается и `callback` добавляется в очередь
`baz` логирует `Third`. Цикл обработки событий видит, что коллстек пуст после возврата `baz`, после чего колбэк добавляется в стек вызовов.
`Callback` логирует `Second`.

Надеюсь, что это заставит вас чувствовать себя более уверено с циклом событий `event loop`!

Не беспокойтесь, если это все еще кажется запутанным, самое важное - понять, откуда могут возникнуть определенные ошибки или специфическое поведение.

[![EnglishMoji!](/img/logo/NeuroCoder.png)](https://vk.com/neurocoder)

## Проблемы?

![Problem](https://media.giphy.com/media/xTiTnGeUsWOEwsGoG4/giphy.gif)

Пишите в [Discord](https://discord.gg/6GDAfXn) или телеграмм [чат](https://t.me/jscampapp), а также подписывайтесь на наши [новости](https://t.me/javascriptapp)

<!-- ![JavaScript Camp](/img/bandlink.png) -->

## Вопросы:

![Question](https://media.giphy.com/media/l0HlRnAWXxn0MhKLK/giphy.gif)

Асинхронность - это:

1. Инструмент, который выводит контекст исполнения функции из синхронного потока
2. Инструмент, который исполняет код построчно
3. Инструмент, который обрабатывает запросы параллельно с загрузкой веб-страниц

Менеджер асинхронных вызовов:

1. `stack`
2. `Event loop`
3. `Объекты высшего класса`

Инструмент, выполняющий код с задержкой в миллисекундах:

1. `delay`
2. `heap`
3. `setTimeout`

<!--
![Description](https://media.giphy.com/media/xT5LMLJOHGWW0PfcYg/giphy.gif)

Схема цикла событий:

![for](/img/javascript/26/00.png)

`Event loop` — это бесконечный цикл, который берёт события из очереди и обрабатывает их.

`Heap` (куча) — объекты собраны в кучу, которая есть не что иное, как название для наименее структурированной части памяти.

`Stack` (стопка, стек) — репрезентация единственного потока выполнения JavaScript-кода . Вызовы функций⚙️ помещаются в стек.

`Browser or Web API’s` (браузерные или веб API) — встроены в браузер и способны предоставлять данные из браузера и окружающей компьютерной    ️ среды и давать возможность выполнять с ними полезные и сложные вещи.

![for](/img/javascript/26/01.png)

## Примеры

![math](https://media.giphy.com/media/3orieN7HEHI0tw8x5C/giphy.gif)

### Пример кода 1

```javascript
function main() {
  console.log('A')
  setTimeout(function exec() {
    console.log('B')
  }, 0)
  console.log('C')
}
main()
// Output
// A
// C
// B
```

Здесь мы видим функцию⚙️ `main`, включающую в себя два 2️⃣ `console.log`, выводящих в консоль `A` и `C`. Между ними находится `setTimeout`, вызов которого выведет в консоль `B` после ожидания в 0 секунд.

![for](/img/javascript/26/02.png)

1. Вызов функции `main` сначала поместит её в стек (в качестве первого элемента `frame`). Потом браузер поместит в стек первое выражение функции `main`, которое представляет собой `console.log('A\)`. Это выражение выполняется и, после завершения, удаляется ➖ из стека. Буква `A` выводится в консоль.
2. Следующее выражение `setTimeout()` с коллбэком `exec()` и временем ожидания в `0` секунд помещается в стек вызовов и выполнение начинается. Функция `setTimeout` использует API браузера для задержки вызова предоставленной функции. Элемент `frame` удаляется ➖ из стека сразу после завершения передачи таймера браузерному API.
3. `console.log('C')` помещается в стек, пока в браузере запускается таймер для вызова функции `exec()`. В этом конкретном случае, поскольку время ожидания составляет `0` секунд, коллбэк (функция `exec()`) будет помещён в `message queue` (очередь сообщений), сразу после того как браузер его получит (в идеале).
4. После выполнения последнего выражения функции `main`, элемент `main` удаляется ➖ из стека вызовов `call stack`, оставляя его пустым. Стек вызовов должен быть пустым, для того чтобы браузер поместил в него элемент из `message queue`. Именно по этой причине даже если в `setTimeout` указано время ожидания в `0` секунд, функция `exec()` не выполняется, пока не закончится выполнение всех элементов в стеке вызовов.
5. Теперь функция `exec()` помещается в стек вызовов и выполняется. Буква `B` выводится в консоль. Вот он — цикл событий `Event Loop` JavaScript.

Таким образом аргумент `delay` в `setTimeout(function, delayTime)` не означает точное время задержки, после которого функция выполнится. Он означает минимальное время ожидания, после которого в какой-нибудь момент времени, функция будет вызвана.

![Wow](https://media.giphy.com/media/QXPmPdudTz4So2P4OQ/giphy.gif)

### Пример кода 2

```javascript
function main() {
  console.log('A')
  setTimeout(function exec() {
    console.log('B')
  }, 0)
  runWhileLoopForNSeconds(3)
  console.log('C')
}

main()

function runWhileLoopForNSeconds(sec) {
  let start = Date.now(),
    now = start
  while (now - start < sec * 1000) {
    now = Date.now()
  }
}
// Output
// A
// C
// B
```

Функция⚙️ `runWhileLoopForNSeconds()` делает именно то, что отражено в её названии. Она постоянно проверяет, прошло ли со времени её вызова то количество секунд, которое передано аргументом. Главное, что нужно помнить — что цикл `while` является блокирующим выражением, и это означает, что его выполнение происходит в стеке вызовов и не использует браузерные API. Таким образом он блокирует все последующие выражения, пока не выполнится до конца.

![for](/img/javascript/26/03.png)

В коде выше, даже несмотря на то, что `setTimeout` имеет задержку в 0 секунд и цикл `while` выполняется 3 секунды, функция⚙️ `exec()` застрянет в очереди сообщений. Цикл `while` будет выполняться в стеке вызовов (в котором один поток), пока не пройдет 3 секунды. И только после того, как стек вызовов опустеет, функция⚙️ `exec()` будет помещена в стек и выполнена.

Таким образом аргумент `delay` в `setTimeout()` не гарантирует начала выполнения после завершения указанной задержки. Он является минимальным временем задержки.

## Контекст исполнения

![goes through the door](https://media.giphy.com/media/3o7TKswXkG2qVFIop2/giphy.gif)

JavaScript — интерпретируемый язык . Это значит, что любой код проходит через интерпретатор, который исполняет его построчно. Но и здесь есть нюансы.

Как только скрипт попадает в интерпретатор, формируются глобальный контекст и глобальная область видимости, в которой держится `Variable Object`, или `VO` — объект переменных  .

Он формируется из переменных вида `Function Declaration` и атрибутов функции⚙️ по следующему принципу. Интерпретатор считывает код и находит все объявления:

- переменных  по ключевому слову `var` (`const` или `let` в ES6 и выше);
- функций, объявленных ключевым словом `function`, без присваивания.

Это складывается в `VO` текущего контекста исполнения. Затем берётся `Variable Object` внешней области видимости и к нему добавляется ➕ сформированный выше `VO`. Сверху он дополняется параметрами функции⚙️ и их значениями на момент исполнения.

При этом нет разницы, в каком месте функции⚙️ они определяются. Переменная  может быть определена в любой части кода , как и функция⚙️.

Рассмотрим скрипт:

```javascript
var a = 10
var c = 7
function func(a, b, d) {
  console.log(a, b, c, d)
  c = a + d
}
var b = 3
func(10, a, b)
console.log(c)
```

`VO` этого скрипта формируется:

1. Из переменной  `a`, значение которой — `undefined`.
2. Переменной  `c`, значение которой — `undefined`.
3. Переменной  `b`, значение которой — `undefined`.
4. Функции `func` с соответствующим телом.

Затем скрипт начнет исполняться по следующему сценарию:

1. В переменную  `a` запишется значение `10`.
2. В переменную `c` запишется значение `7`.
3. В переменную  `b` запишется значение `3`.
4. Будет вызвана функция `func`.
5. Создается контекст исполнения функции `func`.
6. В `VO` контекста исполнения функции `func` будут записаны  переменные  из внешней области видимости: `a`, `c` и `b`, c присвоенными значениями.
7. В `VO` контекста исполнения функции `func` будут созданы переменные  из списка аргументов; поскольку переменные  `a` и `b` уже существуют в VO, добавлена будет только переменная  `d` со значением `undefined`.
8. В переменную  `a` `VO` контекста исполнения функции `func` будет записано  значение `10`.
9. В переменную  `b` `VO` контекста исполнения функции `func` будет записано  значение переменной  a внешней области видимости — `10`.
10. В переменную  `d` `VO` контекста исполнения функции `func` будет записано  значение переменной  `b` внешней области видимости — `3`.
11. Контекст исполнения функции `func` будет запущен.
12. В консоль выведется `10 10 7 3`.
13. В переменную  `c`, находящуюся во внешней области видимости, будет записано  значение `13`.
14. Контекст выполнения функции `func` будет завершён. `VO` функции `func` будет удалён.
15. В консоль выведется `13`.

Теперь перепишем скрипт, добавив `setTimeout` с нулевым тайм-аутом у вызова функции⚙️:

```javascript
var a = 10
var c = 7
function func(a, b, d) {
  console.log(a, b, c, d)
  c = a + d
}
var b = 3
setTimeout(function () {
  func(10, a, b)
}, 0)
console.log(c)
```

На первый взгляд может показаться, что ничего не изменится и функция⚙️ `func` будет выполнена без задержки. Но это не так. На самом деле произойдёт следующее:

1. В переменную  `a` запишется значение `10`.
2. В переменную  `c` запишется значение `7`.
3. В переменную  `b` запишется значение `3`.
4. Функция `func` попадает в пул ожидания.
5. Создаётся контекст исполнения функции `func`.
6. По истечении `0` миллисекунд контекст исполнения функции `func` будет помещён в `event loop`.
7. В консоль выведется `7`.
8. В `VO` контекста исполнения функции `func` будут записаны  переменные  из внешней области видимости: `a`, `c` и `b`, c присвоенными значениями.
9. В `VO` контекста исполнения функции `func` будут созданы переменные  из списка аргументов; поскольку переменные  `a` и `b` уже существуют в `VO`, добавлена будет только переменная  `d` со значением `undefined`.
10. В переменную  `a` `VO` контекста исполнения функции `func` будет записано  значение `10`.
11. В переменную  `b` `VO` контекста исполнения функции `func` будет записано  значение переменной  a внешней области видимости — `10`.
12. В переменную  `d` `VO` контекста исполнения функции `func` будет записано  значение переменной  `b` внешней области видимости — `3`.
13. Контекст исполнения функции `func` будет запущен.
14. В консоль выведется `10 10 7 3`.
15. В переменную  `c`, находящуюся во внешней области видимости, будет записано  значение `13`.
16. Контекст выполнения функции `func` будет завершён; `VO` функции `func` будет удалён.

<!-- ### Примеры

![Math](https://media.giphy.com/media/3o7btPCcdNniyf0ArS/giphy.gif)

`setTimeout` выводит контекст исполнения функции⚙️ из синхронного потока, помещая его в `event loop`. То же самое происходит и с регистрацией событий. Мы можем подписаться на событие при помощи функции⚙️ `addEventListener`. Передавая функцию⚙️ обратного вызова — `callback`, добавляем её в список функций⚙️, которые должны быть вызваны при срабатывании этого события.

Допустим, мы хотим нажатием на кнопку перекрасить её в красный цвет. Код , который это выполняет, выглядит так:

```javascript
var button = document.querySelector('button')

button.addEventListener('click', function (evt) {
  button.style.background = '#f00'
})
```

Более сложный пример: есть две кнопки, первая перекрашивает фон страницы в красный цвет, а вторая — в жёлтый, но у второй перекрашивание фона завёрнуто в `setTimeout` с нулевой задержкой. И мы вручную вызываем событие нажатия сначала на жёлтую кнопку, а потом — на красную.

```javascript
var redButton = document.getElementById(‘red’)
redButton.addEventListener('click', function () {
  document.body.style.background = '#f00'
})
var yellowButton = document.getElementById(‘yellow’)
yellowButton.addEventListener(‘click’, function () {
setTimeout(function () {
         document.body.style.background = ‘#ff0’;
}, 0);
});
yellowButton.click();
redButton.click();
```

Обратите внимание, что исполнение коллбэков событий `click` на кнопках при вызове из кода происходит сразу же, не попадая в `event loop`: `setTimeout` с нулевой задержкой отложил перекраску фона в жёлтый, но функция⚙️ сама была исполнена в момент вызова.

Это происходит из-за того, что события из кода не требуется выполнять асинхронно. Действительно, в такой ситуации мы находимся в предсказуемом окружении, тогда как пользовательские события могут случаться в любой момент.

![Wow](https://media.giphy.com/media/M33UV4NDvkTHa/giphy.gif)


-->

Для того чтобы понять, на сколько вы усвоили этот урок, пройдите тест в [мобильном приложении](http://onelink.to/njhc95) нашей школы по этой теме или в нашем [телеграм боте](https://t.me/javascriptcamp_bot).

[![EnglishMoji!](/img/logo/NeuroCoder.png)](https://vk.com/neurocoder)

## Ссылки:

1. [Объяснение работы EventLoop в JavaScript](https://medium.com/devschacht/javascript-eventloop-explained-f2dcf84e36ee)
2. [Как управлять event loop в JavaScript](https://skillbox.ru/media/code/event_loop_chast_1)
3. [Справочник javascript](https://javascript.ru/settimeout)
4. [Статья: Объяснение Event Loop в Javascript с помощью визуализации](https://bool.dev/blog/detail/obyasnenie-event-loop-v-javascript-s-pomoshchyu-vizualizatsii)
5. [Статья: JavaScript Visualized: Promises & Async/Await](https://medium.com/@lydiahallie/javascript-visualized-promises-async-await-a3f1aad8a943)

## Contributors ✨

Thanks goes to these wonderful people ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/AlisaNasibullina"><img src="https://avatars3.githubusercontent.com/u/74646904?s=460&v=4" width="200px;" alt=""/><br /><sub><b>AlisaNasibullina</b></sub></a><br /><a href="#mentoring-KoDim-React" title="Mentoring">  </a></td>
    <td align="center"><a href="https://fullstackserverless.github.io/"><img src="https://avatars0.githubusercontent.com/u/6774813?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy Vasilev</b></sub></a><br /><a href="#financial-gHashTag" title="Financial">💵</a></td>
  <td align="center"><a href="https://github.com/Resoner2005"><img src="https://avatars1.githubusercontent.com/u/75675814?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Resoner2005</b></sub></a><br /><a href="https://github.com/gHashTag/react-native-village/issues?q=author%3AResoner2005" title="Bug reports">🐛 🎨 </a></td>
  </tr>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

