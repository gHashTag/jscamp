---
id: javascript25
title: حلقة حدث غير متزامن
sidebar_label: حلقة الحدث
---

![@serverSerrverlesskiy](/img/javascript/headers/26.jpg)

## غير متزامن

في JavaScript ، يعد عدم التزامن الأداة الرئيسية التي تعالج الطلبات بالتوازي مع تحميل صفحة الويب. الآن من المستحيل تخيل الإنترنت ، حيث سيتم إرسال جميع الطلبات إلى الخادم مع إعادة تحميل الصفحة.

يتم طلب أي بيانات من الخادم بشكل غير متزامن: يتم إرسال الطلب (XMLHttpRequest أو XHR) ، والرمز لا تنتظر عودته, الاستمرار في التنفيذ. عندما يستجيب الخادم ، يتم إخطار كائن XHR بذلك ويقوم بتشغيل وظيفة رد الاتصال التي تم تمريرها إليه قبل إرسال الطلب.

إذا كنت تستخدم أدوات اللغة بشكل صحيح , ثم تنفيذ الطلب الذي يحدث بشكل متتابع وفي خيط واحد لا يتدخل بأي شكل من الأشكال في استقبال الأحداث ورد الفعل عليها - شخص يعمل بهدوء مع الواجهة ، دون ملاحظة التأخيرات والأعطال والتجميد.

## حلقة الحدث

![Queue](https://media.giphy.com/media/5YuhLwDgrgtRVwI7OY/giphy.gif)

جافا سكريبت `Event loop` هو مدير مكالمات غير متزامن.

لجعل هذه العملية الصعبة تعمل بسلاسة ، تنفذ JavaScript آلية للتحكم في تسلسل تنفيذ التعليمات البرمجية. لأنها لغة ذات ترابط واحد , أصبح من الضروري "الإسفين" في سياق التنفيذ الحالي. هذه الآلية تسمى حلقة الحدث.

من الانجليزية، `loop` يترجم كـ "حلقة" ، وهو ما يعكس المعنى تمامًا: نحن نتعامل مع قائمة انتظار الاسترجاع.

`Event loop` ينظم تسلسل تنفيذ السياقات - المكدس. يتم إنشاؤه عندما يتم تشغيل حدث أو استدعاء وظيفة. يتم وضع الاستجابة للحدث في قائمة انتظار التنفيذ ، في`event loop`,الذي ينفذ بالتسلسل ، مع كل حلقة ، الكود الذي يدخل فيه. في هذه الحالة ، يتم استدعاء الوظيفة المرتبطة بالحدث التالي بعد سياق التنفيذ الحالي.

في JavaScript ، يتم تشغيل قوائم انتظار التنفيذ المتزامن وغير المتزامن باستمرار. متزامن - `stack` - تشكل قائمة انتظار وإعادة توجيهها إلى غير متزامن -`event loop` - استدعاءات الوظائف التي سيتم تنفيذها بعد السياق القابل للتنفيذ المجدول حاليًا.

لكي تكون البيانات في حالة متسقة ، يجب إكمال كل وظيفة. ويرجع ذلك إلى الترابط الفردي لجافا سكريبت وبعض الميزات الأخرى ، مثل خصائص الإغلاق المميزة "للغات" الوظيفية للبرمجة. لذلك ، يتم تمثيل خيط واحد كقائمة انتظار لسياقات التنفيذ ، حيث تكون الوظائف التي مرت عبر حلقة الحدث "مثبتة".

## وصف

JavaScript هي لغة ذات ترابط واحد: يمكن تشغيل مهمة واحدة فقط في كل مرة. هذه ليست مشكلة كبيرة في العادة ، لكن تخيل الآن أنك تقوم بمهمة تستغرق 30 ثانية ... نعم. أثناء هذه المهمة ، ننتظر 30 ثانية قبل أن يحدث أي شيء آخر (افتراضيًا ، يتم تشغيل JavaScript على سلسلة المتصفح الرئيسية ، لذلك ستنتظر واجهة المستخدم بأكملها)  إنه عام 2021 الآن ، لا أحد يريد موقعًا بطيئًا وغبيًا.

لحسن الحظ ، يوفر لنا المتصفح بعض الوظائف التي لا توفرها JavaScript نفسها: واجهة برمجة تطبيقات الويب. والتي تتضمن DOM API و setTimeout وطلبات HTTP وما إلى ذلك. يمكن أن يساعدنا هذا في إنشاء سلوك غير متزامن غير معطل.

عندما نستدعي وظيفة ، تتم إضافتها إلى مكدس الاستدعاءات. مكدس الاستدعاءات هو جزء من محرك JS ، وهو مستعرض مستقل. هذه طريقة عرض كلاسيكية للمكدس ، أي `first in`,` last out`. عندما تعود دالة ، تنبثق من المكدس.

```javascript
function great() {
  return 'Hello'
}

function respond() {
  return setTimeout(() => alert('Hey!'), 1000)
}

great()
respond()
```

![stack](/img/javascript/27/stack.gif)

تقوم وظيفة الاستجابة بإرجاع الدالة setTimeout. `SetTimeout` يتم توفيره لنا من خلال` Web-API`: يسمح لنا بتقسيم المهام دون حجب الخيط الرئيسي. ال `Callback` وظيفة مررناها إلى` setTimeout` وظيفة`() => {return 'Hey'}` تمت إضافة وظيفة lambda إلى ملف`Web-API`. وفى الوقت نفسه، `setTimeout` و`responde` من المكدس وإرجاع قيمها.

![timer](/img/javascript/27/timer.gif)

في `Web-API`, يعمل الموقت حتى تنتظر الوسيطة الثانية التي مررناها إليها 1000 مللي ثانية. لا تتم إضافة رد الاتصال على الفور إلى مكدس الاستدعاءات ، ولكن يتم تمريره إلى ما يسمى قائمة الانتظار.

![queue](/img/javascript/27/queue.gif)

قد يكون هذا محيرًا: فهذا لا يعني أن ملف `callback` تضاف وظيفة إلى مكدس الاستدعاءات (وبالتالي إرجاع قيمة) بعد 1000 مللي ثانية! تتم إضافته إلى قائمة الانتظار بعد 1000 مللي ثانية. ولكن في قائمة الانتظار هذه ، يجب أن تنتظر الوظيفة حتى يحين دورها.

الآن هذا هو الجزء الذي كنا ننتظره جميعًا ... حان الوقت لفعل حلقة الحدث شيئًا واحدًا: توصيل قائمة الانتظار بمكدس المكالمات! إذا كانت مكدس الاستدعاءات فارغًا ، أي إذا أعادت جميع الوظائف التي تم استدعاؤها سابقًا قيمها وتم إخراجها من المكدس ، فسيتم إضافة العنصر الأول في قائمة الانتظار إلى مكدس الاستدعاءات. في هذه الحالة ، لم يتم استدعاء أي وظائف أخرى ، مما يعني أن مكدس الاستدعاءات كان فارغًا بحلول الوقت`callback` كانت الوظيفة العنصر الأول في قائمة الانتظار.

![qtoc](/img/javascript/27/qtoc.gif)

يتم دفع رد الاتصال إلى مكدس المكالمات ، ويتم استدعاؤه وإعادته ، وإزالته من المجموعة.

![result](/img/javascript/27/res.gif)

من الممتع مشاهدتها ، لكن لا يمكنك استيعاب موضوع بالكامل دون العمل عليه مرارًا وتكرارًا. حاول معرفة ما يظهر في وحدة التحكم إذا قمنا بتشغيل ما يلي:

```jsx
const foo = () => console.log('First')
const bar = () => setTimeout(() => console.log('Second'), 500)
const baz = () => console.log('Third')

bar()
foo()
baz()
```

دعونا نرى ما يحدث عندما نقوم بتشغيل هذا الرمز في المتصفح:

![br](/img/javascript/27/br.gif)

نحن نتصل `bar`, الذي يعيد ال`setTimeout` وظيفة.
ال`Callback` الذي مررنا إليه `setTimeout` يضاف إلى `Web API`, ال`setTimeout` و`bar` تنبثق وظائف من مكدس المكالمات.

في غضون ذلك ، يبدأ الموقت `foo` يسمى والسجلات `First`. `foo` عائدات `undefined`, `baz` يسمى و `callback` يضاف إلى قائمة الانتظار
`baz` السجلات` Third`. ترى حلقة الحدث أن callstack فارغ بعد عودة baz ، وبعد ذلك تتم إضافة رد الاتصال إلى مكدس الاستدعاءات.
`Callback` السجلات`Second`.

آمل أن يجعلك هذا تشعر بمزيد من الثقة مع`event loop`!

لا تقلق إذا كان هذا لا يزال يبدو محيرًا ، فالشيء الأكثر أهمية هو فهم مصدر أخطاء معينة أو سلوك معين.

## مشاكل؟

![Problem](https://media.giphy.com/media/xTiTnGeUsWOEwsGoG4/giphy.gif)

اكتب ل[Discord](https://discord.gg/6GDAfXn) محادثة.

## أسئلة:

![Question](https://media.giphy.com/media/l0HlRnAWXxn0MhKLK/giphy.gif)

عدم التزامن هو:

1. أداة تعرض سياق تنفيذ وظيفة من دفق متزامن
2. أداة تنفذ التعليمات البرمجية سطرًا بسطر
3. أداة تعالج الطلبات بالتوازي مع تحميل صفحات الويب

مدير الاتصال غير المتزامن:

1. `stack`
2. `Event loop`
3. `JavaScript`

يتم إجراء مكالمات الوظائف في:

1. كومة
2. حفنة من
3. حلقة

الأداة التي تنفذ التعليمات البرمجية بتأخير ميلي ثانية:

1. `delay`
2. `heap`
3. `setTimeout`

<!--
![Description](https://media.giphy.com/media/xT5LMLJOHGWW0PfcYg/giphy.gif)

Схема цикла событий:

![for](/img/javascript/26/00.png)

`Event loop` — это бесконечный цикл, который берёт события из очереди и обрабатывает их.

`Heap` (куча) — объекты собраны в кучу, которая есть не что иное, как название для наименее структурированной части памяти.

`Stack` (стопка, стек) — репрезентация единственного потока выполнения JavaScript-кода . Вызовы функций⚙️ помещаются в стек.

`Browser or Web API’s` (браузерные или веб API) — встроены в браузер и способны предоставлять данные из браузера и окружающей компьютерной    ️ среды и давать возможность выполнять с ними полезные и сложные вещи.

![for](/img/javascript/26/01.png)

## Примеры

![math](https://media.giphy.com/media/3orieN7HEHI0tw8x5C/giphy.gif)

### Пример кода 1

```javascript
function main() {
  console.log('A')
  setTimeout(function exec() {
    console.log('B')
  }, 0)
  console.log('C')
}
main()
// Output
// A
// C
// B
```

Здесь мы видим функцию⚙️ `main`, включающую в себя два 2️⃣ `console.log`, выводящих в консоль `A` и `C`. Между ними находится `setTimeout`, вызов которого выведет в консоль `B` после ожидания в 0 секунд.

![for](/img/javascript/26/02.png)

1. Вызов функции `main` сначала поместит её в стек (в качестве первого элемента `frame`). Потом браузер поместит в стек первое выражение функции `main`, которое представляет собой `console.log('A\)`. Это выражение выполняется и, после завершения, удаляется ➖ из стека. Буква `A` выводится в консоль.
2. Следующее выражение `setTimeout()` с коллбэком `exec()` и временем ожидания в `0` секунд помещается в стек вызовов и выполнение начинается. Функция `setTimeout` использует API браузера для задержки вызова предоставленной функции. Элемент `frame` удаляется ➖ из стека сразу после завершения передачи таймера браузерному API.
3. `console.log('C')` помещается в стек, пока в браузере запускается таймер для вызова функции `exec()`. В этом конкретном случае, поскольку время ожидания составляет `0` секунд, коллбэк (функция `exec()`) будет помещён в `message queue` (очередь сообщений), сразу после того как браузер его получит (в идеале).
4. После выполнения последнего выражения функции `main`, элемент `main` удаляется ➖ из стека вызовов `call stack`, оставляя его пустым. Стек вызовов должен быть пустым, для того чтобы браузер поместил в него элемент из `message queue`. Именно по этой причине даже если в `setTimeout` указано время ожидания в `0` секунд, функция `exec()` не выполняется, пока не закончится выполнение всех элементов в стеке вызовов.
5. Теперь функция `exec()` помещается в стек вызовов и выполняется. Буква `B` выводится в консоль. Вот он — цикл событий `Event Loop` JavaScript.

Таким образом аргумент `delay` в `setTimeout(function, delayTime)` не означает точное время задержки, после которого функция выполнится. Он означает минимальное время ожидания, после которого в какой-нибудь момент времени, функция будет вызвана.

![Wow](https://media.giphy.com/media/QXPmPdudTz4So2P4OQ/giphy.gif)

### Пример кода 2

```javascript
function main() {
  console.log('A')
  setTimeout(function exec() {
    console.log('B')
  }, 0)
  runWhileLoopForNSeconds(3)
  console.log('C')
}

main()

function runWhileLoopForNSeconds(sec) {
  let start = Date.now(),
    now = start
  while (now - start < sec * 1000) {
    now = Date.now()
  }
}
// Output
// A
// C
// B
```

Функция⚙️ `runWhileLoopForNSeconds()` делает именно то, что отражено в её названии. Она постоянно проверяет, прошло ли со времени её вызова то количество секунд, которое передано аргументом. Главное, что нужно помнить — что цикл `while` является блокирующим выражением, и это означает, что его выполнение происходит в стеке вызовов и не использует браузерные API. Таким образом он блокирует все последующие выражения, пока не выполнится до конца.

![for](/img/javascript/26/03.png)

В коде выше, даже несмотря на то, что `setTimeout` имеет задержку в 0 секунд и цикл `while` выполняется 3 секунды, функция⚙️ `exec()` застрянет в очереди сообщений. Цикл `while` будет выполняться в стеке вызовов (в котором один поток), пока не пройдет 3 секунды. И только после того, как стек вызовов опустеет, функция⚙️ `exec()` будет помещена в стек и выполнена.

Таким образом аргумент `delay` в `setTimeout()` не гарантирует начала выполнения после завершения указанной задержки. Он является минимальным временем задержки.

## Контекст исполнения

![goes through the door](https://media.giphy.com/media/3o7TKswXkG2qVFIop2/giphy.gif)

JavaScript — интерпретируемый язык . Это значит, что любой код проходит через интерпретатор, который исполняет его построчно. Но и здесь есть нюансы.

Как только скрипт попадает в интерпретатор, формируются глобальный контекст и глобальная область видимости, в которой держится `Variable Object`, или `VO` — объект переменных  .

Он формируется из переменных вида `Function Declaration` и атрибутов функции⚙️ по следующему принципу. Интерпретатор считывает код и находит все объявления:

- переменных  по ключевому слову `var` (`const` или `let` в ES6 и выше);
- функций, объявленных ключевым словом `function`, без присваивания.

Это складывается в `VO` текущего контекста исполнения. Затем берётся `Variable Object` внешней области видимости и к нему добавляется ➕ сформированный выше `VO`. Сверху он дополняется параметрами функции⚙️ и их значениями на момент исполнения.

При этом нет разницы, в каком месте функции⚙️ они определяются. Переменная  может быть определена в любой части кода , как и функция⚙️.

Рассмотрим скрипт:

```javascript
var a = 10
var c = 7
function func(a, b, d) {
  console.log(a, b, c, d)
  c = a + d
}
var b = 3
func(10, a, b)
console.log(c)
```

`VO` этого скрипта формируется:

1. Из переменной  `a`, значение которой — `undefined`.
2. Переменной  `c`, значение которой — `undefined`.
3. Переменной  `b`, значение которой — `undefined`.
4. Функции `func` с соответствующим телом.

Затем скрипт начнет исполняться по следующему сценарию:

1. В переменную  `a` запишется значение `10`.
2. В переменную `c` запишется значение `7`.
3. В переменную  `b` запишется значение `3`.
4. Будет вызвана функция `func`.
5. Создается контекст исполнения функции `func`.
6. В `VO` контекста исполнения функции `func` будут записаны  переменные  из внешней области видимости: `a`, `c` и `b`, c присвоенными значениями.
7. В `VO` контекста исполнения функции `func` будут созданы переменные  из списка аргументов; поскольку переменные  `a` и `b` уже существуют в VO, добавлена будет только переменная  `d` со значением `undefined`.
8. В переменную  `a` `VO` контекста исполнения функции `func` будет записано  значение `10`.
9. В переменную  `b` `VO` контекста исполнения функции `func` будет записано  значение переменной  a внешней области видимости — `10`.
10. В переменную  `d` `VO` контекста исполнения функции `func` будет записано  значение переменной  `b` внешней области видимости — `3`.
11. Контекст исполнения функции `func` будет запущен.
12. В консоль выведется `10 10 7 3`.
13. В переменную  `c`, находящуюся во внешней области видимости, будет записано  значение `13`.
14. Контекст выполнения функции `func` будет завершён. `VO` функции `func` будет удалён.
15. В консоль выведется `13`.

Теперь перепишем скрипт, добавив `setTimeout` с нулевым тайм-аутом у вызова функции⚙️:

```javascript
var a = 10
var c = 7
function func(a, b, d) {
  console.log(a, b, c, d)
  c = a + d
}
var b = 3
setTimeout(function () {
  func(10, a, b)
}, 0)
console.log(c)
```

На первый взгляд может показаться, что ничего не изменится и функция⚙️ `func` будет выполнена без задержки. Но это не так. На самом деле произойдёт следующее:

1. В переменную  `a` запишется значение `10`.
2. В переменную  `c` запишется значение `7`.
3. В переменную  `b` запишется значение `3`.
4. Функция `func` попадает в пул ожидания.
5. Создаётся контекст исполнения функции `func`.
6. По истечении `0` миллисекунд контекст исполнения функции `func` будет помещён в `event loop`.
7. В консоль выведется `7`.
8. В `VO` контекста исполнения функции `func` будут записаны  переменные  из внешней области видимости: `a`, `c` и `b`, c присвоенными значениями.
9. В `VO` контекста исполнения функции `func` будут созданы переменные  из списка аргументов; поскольку переменные  `a` и `b` уже существуют в `VO`, добавлена будет только переменная  `d` со значением `undefined`.
10. В переменную  `a` `VO` контекста исполнения функции `func` будет записано  значение `10`.
11. В переменную  `b` `VO` контекста исполнения функции `func` будет записано  значение переменной  a внешней области видимости — `10`.
12. В переменную  `d` `VO` контекста исполнения функции `func` будет записано  значение переменной  `b` внешней области видимости — `3`.
13. Контекст исполнения функции `func` будет запущен.
14. В консоль выведется `10 10 7 3`.
15. В переменную  `c`, находящуюся во внешней области видимости, будет записано  значение `13`.
16. Контекст выполнения функции `func` будет завершён; `VO` функции `func` будет удалён.

<!-- ### Примеры

![Math](https://media.giphy.com/media/3o7btPCcdNniyf0ArS/giphy.gif)

`setTimeout` выводит контекст исполнения функции⚙️ из синхронного потока, помещая его в `event loop`. То же самое происходит и с регистрацией событий. Мы можем подписаться на событие при помощи функции⚙️ `addEventListener`. Передавая функцию⚙️ обратного вызова — `callback`, добавляем её в список функций⚙️, которые должны быть вызваны при срабатывании этого события.

Допустим, мы хотим нажатием на кнопку перекрасить её в красный цвет. Код , который это выполняет, выглядит так:

```javascript
var button = document.querySelector('button')

button.addEventListener('click', function (evt) {
  button.style.background = '#f00'
})
```

Более сложный пример: есть две кнопки, первая перекрашивает фон страницы в красный цвет, а вторая — в жёлтый, но у второй перекрашивание фона завёрнуто в `setTimeout` с нулевой задержкой. И мы вручную вызываем событие нажатия сначала на жёлтую кнопку, а потом — на красную.

```javascript
var redButton = document.getElementById(‘red’)
redButton.addEventListener('click', function () {
  document.body.style.background = '#f00'
})
var yellowButton = document.getElementById(‘yellow’)
yellowButton.addEventListener(‘click’, function () {
setTimeout(function () {
         document.body.style.background = ‘#ff0’;
}, 0);
});
yellowButton.click();
redButton.click();
```

Обратите внимание, что исполнение коллбэков событий `click` на кнопках при вызове из кода происходит сразу же, не попадая в `event loop`: `setTimeout` с нулевой задержкой отложил перекраску фона в жёлтый, но функция⚙️ сама была исполнена в момент вызова.

Это происходит из-за того, что события из кода не требуется выполнять асинхронно. Действительно, в такой ситуации мы находимся в предсказуемом окружении, тогда как пользовательские события могут случаться в любой момент.

![Wow](https://media.giphy.com/media/M33UV4NDvkTHa/giphy.gif)


-->

لفهم مقدار ما تعلمته في هذا الدرس ، قم بإجراء الاختبار في[mobile application](http://onelink.to/njhc95) من مدرستنا في هذا الموضوع.

[![EnglishMoji!](/img/logo/NeuroCoder.png)](https://vk.com/neurocoder)

## الروابط:

1. [Explaining how EventLoop works in JavaScript](https://medium.com/devschacht/javascript-eventloop-explained-f2dcf84e36ee)
2. [How to manage event loop in JavaScript](https://skillbox.ru/media/code/event_loop_chast_1)
3. [Javascript reference](https://javascript.ru/settimeout)
4. [Article: Explaining Event Loop in Javascript Using Rendering](https://bool.dev/blog/detail/obyasnenie-event-loop-v-javascript-s-pomoshchyu-vizualizatsii)
5. [Article: JavaScript Visualized: Promises & Async / Await](https://medium.com/@lydiahallie/javascript-visualized-promises-async-await-a3f1aad8a943)

## المساهمون ✨

الشكر يعود إلى هؤلاء الأشخاص الرائعين([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/AlisaNasibullina"><img src="https://avatars3.githubusercontent.com/u/74646904?s=460&v=4" width="200px;" alt=""/><br /><sub><b>AlisaNasibullina</b></sub></a><br /><a href="#mentoring-KoDim-React" title="Mentoring">  </a></td>
    <td align="center"><a href="https://fullstackserverless.github.io/"><img src="https://avatars0.githubusercontent.com/u/6774813?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy Vasilev</b></sub></a><br /><a href="#financial-gHashTag" title="Financial">💵</a></td>
  <td align="center"><a href="https://github.com/Resoner2005"><img src="https://avatars1.githubusercontent.com/u/75675814?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Resoner2005</b></sub></a><br /><a href="https://github.com/gHashTag/react-native-village/issues?q=author%3AResoner2005" title="Bug reports">🐛 🎨 </a></td>
  </tr>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

[![EnglishMoji!](/img/logo/NeuroCoder.png)](https://vk.com/neurocoder)
