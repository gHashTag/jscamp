---
id: javascript16
title: دورات
sidebar_label: دورات
---

![@serverSerrverlesskiy](/img/javascript/headers/17.jpg)

عندما يحتاج إجراء ما إلى تكرار عدد كبير من المرات ، يتم استخدام الدورات في البرمجة. على سبيل المثال ، تحتاج إلى عرض النص "Hello, World!" . بدلاً من تكرار نفس أمر إخراج النص  مائتي مرة ، غالبًا ما يتم إنشاء حلقة تكرر 200 مرة ما هو مكتوب في جسم الحلقة. كل تكرار يسمى التكرار.

![cycle](https://media.giphy.com/media/Pkck2unt0XQfc4gs3R/giphy.gif)

التكرار في البرمجة - بالمعنى الواسع - تنظيم معالجة البيانات حيث تتكرر الإجراءات عدة مرات ، دون أن يؤدي ذلك إلى استدعاءات📞 tأنفسهم (على عكس العودية). بالمعنى الضيق ، إنها خطوة واحدة في عملية دورية متكررة.

حلقة في JavaScript (وبجميع اللغات الأخرى ) هو جزء من التعليمات البرمجية التي تكرر نفسها طالما أن الشرط المعروف صحيح. هناك العديد من الأنواع المختلفة من الحلقات ، لكنهم جميعًا يفعلون نفس الشيء: يكررون فعلًا عدة مرات.

## حلقة while ()

![While](https://media.giphy.com/media/WS6CDvvyNDrhZRFBtT/giphy.gif)

ال `while` يُنشئ عامل التشغيل حلقة تنفذ التعليمات المحددة بينما يكون الشرط قيد الاختبار صحيحًا. يتم حساب القيمة المنطقية للشرط вычис قبل تنفيذ جسم الحلقة.

### بناء الجملة

![Boock](https://media.giphy.com/media/LkjlH3rVETgsg/giphy.gif)

```javascript
while (condition) {
  instruction // algorithm code - instructions
}
```

`condition` هو تعبير يتم فحص قيمته المنطقية في كل مرة قبل الدخول في الحلقة. إذا كانت القيمة صحيحة -`true`, ثم يتم تنفيذ التعليمات. عندما تصبح القيمة خاطئة- `false`, نخرج من الحلقة.

التعليمات هي رمز خوارزمية يتم تنفيذه في كل مرة يكون فيها الشرط صحيحًا. لتنفيذ تعليمات متعددة في حلقة ، استخدم عامل تشغيل البلوك "{...}` لتجميعهم. عند استخدام أمر واحد في جسم الحلقة ، يمكن حذف الأقواس المتعرجة.

هنا مثال بسيط للحلقة `while (condition) {...}`

```jsx live
function learnJavaScript() {
  let count = 0 // count is a counter
  let result = 'Account:'
  // change account to any
  while (count < 10) {
    result += count + ', '
    count++
  }
  return result
}
```

"العدد" في المثال هو "0". شرط الحلقة الخاصة بنا (مكتوب скоб بين قوسين) هو أن الكتلة التي تحتوي على الكود سوف تكرر نفسها مرارًا وتكرارًا حتى (أي "الوقت" الفعلي) "العدد" أقل من "10".

نظرًا لأن القيمة الأولية لـ "0" أقل من "10" ، فإن الرمز أشواط. في كل مرة يعيد المترجم التحقق من الشرط ، إذا كان الشرط لا يزال صحيحًا ، عندئذٍ الرمز سيتم تشغيله مرة أخرى. في كل مرة نزيد قيمة العداد بـ "1". خلاف ذلك ، ستبقى القيمة عند `0` ، لذلك سيظل شرطنا` counter <10` صحيحًا دائمًا ، وسيتكرر الكود إلى الأبد!


نتيجة لذلك ، بعد "10" دورات ، ستصبح "10". بعد ذلك ، سينهي المترجم الحلقة لأن الشرط هو `false`  وانتقل إلى الأسطر الأخيرة من التعليمات البرمجية الخاصة بنا.

<!-- ## Цикл do … while

![Check](https://media.giphy.com/media/PijzuUzUhm7hcWinGn/giphy.gif)

Проверку ✔️ условия можно разместить под телом цикла, используя специальный синтаксис   `do .. while`:

```javascript
do {
  // тело цикла
} while (условие)
```

Цикл сначала выполнит тело, а затем проверит ✔️ условие (condition - `состояние`), и пока его значение равно `true`  , он будет выполняться снова и снова.

Например, посчитаем сумму чисел от `0` до `25`  :

```jsx live
function learnJavaScript() {
  let sum = 0
  let i = 0
  do {
    sum += i
    i++
  } while (i < 25)

  return sum
}
```

Такая форма синтаксиса   оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным  . -->

## حلقة for ()

![Create](https://media.giphy.com/media/XaExByjWTK1V2HgDfh/giphy.gif)

يُنشئ التعبير `for` حلقة من ثلاثة تعبيرات اختيارية بين أقواس ، مفصولة بفواصل منقوطة.

### بناء الجملة

![Book](https://media.giphy.com/media/l1J9HWBKLp20YfNAY/giphy.gif)

```javascript
for ([initialization]; [condition]; [final expression])
   { expression }
```

`initialization`- التعبير عن المتغيرات أو تعريفها. يمكن أن يعلن هذا التعبير اختياريًا عن متغيرات جديدة باستخدام الكلمة الأساسية `Let`. هذه المتغيرات مرئية فقط في حلقة "for" ، أي في نفس النطاق (للأمان).

`condition` هو تعبير يتم تنفيذه عند كل تكرار للحلقة. إذا كان التعبير صحيحًا ، يتم تنفيذ الحلقة. الشرط اختياري. إذا لم يكن الأمر كذلك ، فإن الشرط يعتبر دائمًا صحيحًا. إذا كان التعبير خاطئًا ، فسيتم إنهاء تنفيذ "من أجل".

`final expression` - تعبير يتم تنفيذه في نهاية تكرار الحلقة. يحدث حتى يتم استيفاء الشرط التالي. عادة ما تستخدم ل `increment ++`, `decrement -` or `update i + = 5` من متغير العداد.

`expression` - الكود القابل للتنفيذ للخوارزمية بينما حالة الحلقة هي`true`. لتنفيذ عدة تعبيرات في حلقة ، استخدم`{...}` منع لتجميع تلك التعبيرات. لتجنب تنفيذ أي تعبير في حلقة ، استخدم فارغة `for (;;;)` التعبير.

لنحسب مجموع الأعداد من 0 إلى 100 :

```jsx live
function learnJavaScript() {
  let sum = 0
  for (let i = 0; i <= 100; i++) {
    sum += i
  }

  return sum
}
```

تذكر عندما كتبنا 1️⃣ أول`while()` ماذا حدث للعداد لدينا؟ وجدنا أنه من المهم جدًا أن يتغير باستمرار (`increment ++` ساعدنا في هذا). لأنه إذا نسيت ذلك ، فعندئذٍ الرمز سوف تقع في`infinite loop of loops`.

حسنًا ، مثل هذه المواقف تحدث بانتظام مع `while-loops`,وهذا هو السبب `for` مع عداد مدمج!

### مثال على الحلقة

![hmm](https://media.giphy.com/media/l3nSILUHhuVDuWSnC/giphy.gif)

عندما ترى بناء الجملة لأول مرة   من أ`loop for`,قد تعتقد🤔 أن هذا شيء غريب جدًا. لكن لا يزال عليك دراستها🎓, منذ أن تلتقي
مثل هذا مرات عديدة:

```jsx live
function learnJavaScript() {
  let result = 'Score: '

  for (let i = 0; i < 10; i++) {
    result += i + ' '
  }

  return result
}
```

![Wow](https://media.giphy.com/media/3oriO13KTkzPwTykp2/giphy.gif)

حسنا هل تعلم؟ يحب ان يحصلوا على! بعد كل شيء ، هذا هو نفس الرمز عمليا التي استخدمناها في`while` حلقة في بداية الفصل! الأجزاء الثلاثة من الدورة مفصولة بفواصل منقوطة ؛ كانوا جميعًا في حلقة أثناء ذلك ، ولكن في أماكن مختلفة. دعونا نلقي نظرة فاحصة:

![for](/img/javascript/14/00.png)

1.أولاً ، نعلن عن متغير مضاد -`let i = 0`.هذا هو في الوظيفة نفسها وخارج هذه الحلقة `i` سيكون غائبا ، وهذا آمن!

2. بعد ذلك ، نضع شرطًا سيتحقق منه المترجم قبل كل تكرار للحلقة (لتحديد ما إذا كان الأمر يستحق بدء الكود على الإطلاق). يسمى التكرار تكرارًا واحدًا للحلقة (على سبيل المثال ، إذا كان لدينا 10 دورات بدء تشغيل ، فيمكننا القول أنه كان هناك 10 تكرارات للشفرة).
3. الجزء الثالث من الكود الخاص بنا هو `increment ++` (or `decrement --`). يتم تشغيله في نهاية كل تكرار لتغيير متغيرنا في كل مرة.

## استنتاج

![The and](https://media.giphy.com/media/l1Lc1Kn9hImgpx5Re/giphy.gif)

دائمًا تقريبًا ، عندما تعرف عدد التكرارات المطلوبة ، تفضل العمل معها لفترة من الوقت. لهذا السبب تحظى حلقات "for" بشعبية كبيرة. هناك دورات أخرى ، لكنها ليست شائعة جدًا ويمكنك التعرف عليها إذا أردت[here](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/%D0%A6%D0%B8%D0%BA%D0%BB%D1%8B_%D0%B8_%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8).

## مشاكل؟

![Problem](https://media.giphy.com/media/xTiTnGeUsWOEwsGoG4/giphy.gif)

اكتب ل [Discord](https://discord.gg/6GDAfXn) محادثة.

## أسئلة:

![Question](https://media.giphy.com/media/l0HlRnAWXxn0MhKLK/giphy.gif)

ما اسم كتلة الكود التي تكرر نفسها مرارًا وتكرارًا حتى يصبح الشرط المحدد غير صحيح؟

1. دورة
2. الشرط
3. التهيئة

أي من مشغلي الحلقة أكثر شيوعًا؟
1. `for`
2. `while`
3. `break`

كم عدد الرسائل التي سيتم إخراج الكود التالي إلى وحدة التحكم؟

```javascript
let k = 0
while (k < 7) {
  console.log('one more line!')
}
```

1. `7`
2. `8`
3. `infinity`

ما هو الحرف المستخدم لفصل أجزاء حلقة for الموجودة بين قوسين؟

1. `&&`
2. `;`
3. `=!`

إذا ظل `` _______ '' دائمًا صحيحًا ، فيمكن أن يتعطل الكود في "_______" لانهائي.

1. حالة / حلقة
2. دورة / شرط

ما هو الوسط "_____" من الأجزاء الثلاثة الموضوعة بين قوسين من حلقة `for` الذي يسمى؟

1. التعبير
2. الشرط
3. الزيادة

كم عدد الرسائل التي سيتم إخراج الكود التالي إلى وحدة التحكم؟

```javascript
const maxNumer = 17
let n = 0
while (n <= maxNumer) {
  console.log("Let's count!" + n)
  n = n + 2
}
```

1. `8`
2. `9`
3. `10`

ما هو المصطلح لمرور واحد (خطوة) من الدورة؟

1. التكرار
2. المقاطعة
3. التكرار

لفهم مقدار ما تعلمته في هذا الدرس ، قم بإجراء الاختبار في [mobile application](http://onelink.to/njhc95) من مدرستنا في هذا الموضوع.

[![EnglishMoji!](/img/logo/NeuroCoder.png)](https://vk.com/neurocoder)

## الروابط

1. [MDN web doc. The article "The do ... while loop"](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/do...while)
2. [MDN web doc. For Loop Article](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for)
3. [MDN web doc. The while loop](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/while)
4. [Iteration article, Javascript Express site](https://www.javascript.express/syntax/iteration)
5. [While and for Loops](https://learn.javascript.ru/while-for)
6. [Code for Teens: The Perfect Beginner's Guide to Programming, Volume 1: Javascript - Jeremy Moritz](https://www.amazon.com/Code-Teens-Beginners-Programming-Javascript-ebook/dp/B07FCTLVPC)

## المساهمون ✨

الشكر يعود إلى هؤلاء الأشخاص الرائعين ([emoji key](https://allcontributors.org/docs/en/emoji-key)):

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/KoDim-React"><img src="https://avatars1.githubusercontent.com/u/72087863?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy K.</b></sub></a><br /><a href="#mentoring-KoDim-React" title="Mentoring">  </a></td>
    <td align="center"><a href="https://fullstackserverless.github.io/"><img src="https://avatars0.githubusercontent.com/u/6774813?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Dmitriy Vasilev</b></sub></a><br /><a href="#financial-gHashTag" title="Financial">💵</a></td>
    <td align="center"><a href="https://github.com/Resoner2005"><img src="https://avatars1.githubusercontent.com/u/75675814?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Resoner2005</b></sub></a><br /><a href="https://github.com/gHashTag/react-native-village/issues?q=author%3AResoner2005" title="Bug reports">🐛 🎨 🖋</a></td>
    <td align="center"><a href="https://github.com/Navernoss"><img src="https://avatars0.githubusercontent.com/u/75784137?v=4?s=200" width="200px;" alt=""/><br /><sub><b>Navernoss</b></sub></a><br /><a href="#content-Navernoss" title="Content">🖋 🐛 🎨 </a></td>
  </tr>
  
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

[![EnglishMoji!](/img/logo/NeuroCoder.png)](https://vk.com/neurocoder)

<!--

### Жизненный цикл

Рассмотрим пример цикла `while` из реальной жизни.
Предположим, вы — трёхлетний малыш (вам же когда‑то было три, так ведь?). Всё утро вы с упоением играли в конструктор, но тут пришла мама и сказала, что пора заканчивать, а все кубики нужно собрать в коробку. А их тут на полу несметные сотни! Вы быстро прикидываете в уме и понимаете, что за раз вам с этим никак не управиться. Так что вы приходите к единственному разумному решению в такой ситуации: начинаете плакать. И тут ваша мама поражает вас до глубины души, предлагая простое решение, казалось бы, неразрешимой проблемы: она берёт сначала часть кубиков, затем кладёт их в коробку, затем возвращается и… повторяет то же самое! И этот удивительный трюк нужно будет проделать столько раз, сколько потребуется, чтобы все кубики
с пола перекочевали в коробку.

Вы прикидываете в уме… Ну да, вроде всё верно! Должно сработать while()!

Давайте шаг за шагом разберём мамин план:

- Предположим, вы выяснили, что ваша `oneCube` - кубикоПодъёмность (то есть то, сколько кубиков за раз вы сможете унести) — постоянная величина (вы понимаете — константа) и равняется 10.
- Давайте также предположим, что `countCube` - кубиковНаПолу разбросано 120 штук.
- Инструкции таковы: взять наибольшее возможное количество кубиков с пола и перенести их в коробку (то есть вычесть нашу `кубикоПодъёмность` из `кубиковНаПолу`).
- Всё время, пока (то есть while) `кубикиНаПолу` ещё остаются (то есть пока наше условие остаётся истинным), нам предстоит возвращаться (то есть совершать цикл) к выполнению инструкции.

Вот вариант этого плана на языке JavaScript:

```jsx live
function learnJavaScript() {
  const oneCube = 10
  let countCube = 120
  console.log('На полу ' + countCube + ' кубиков.')
  while (countCube > 0) {
    // комбинированное присваивание: `x -= y;` то же, что и `x = x - y;`
    countCube = countCube - oneCube
    console.log('Я убрал в коробку ' + oneCube + ' кубиков, и теперь на полу осталось только ' + countCube + '.')
  }
  console.log('Ура-а-а! Все кубики уложены в коробку!')
}
```

```
На полу 120 кубиков.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 110.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 100.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 90.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 80.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 70.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 60.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 50.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 40.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 30.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 20.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 10.
 Я убрал в коробку 10 кубиков, и теперь на полу осталось только 0.
 Ура-а-а! Все кубики уложены в коробку!
```

Надеюсь, тут всё понятно? И смотрите, какая занятная штука: всё то же самое вы можете проделать с любым количеством `countCube - кубиковНаПолу`, а количество необходимого для этого кода останется примерно тем же! Чтобы показать вам, насколько гибкими могут быть циклы, мы завернём наш код в `функцию с этим параметром`.

Итак, у нас должен выйти следующий рассказ созданный программой:

```jsx live
function learnJavaScript() {
  // oneCube - кубикоПодъёмность
  let oneCube = 10
  // countCube - кубиковНаПолу

  let clearing = function (countCube) {
    let result = 'На полу ' + countCube + ' кубиков. \n'

    while (countCube > 0) {
      countCube = countCube - oneCube
      result += 'Я убрал в коробку ' + oneCube + ' кубиков, и теперь на полу осталось только ' + countCube + '. \n'
    }

    result += '\n Ура-а-а! Все кубики уложены в коробку!'
    return result
  }

  return clearing(70)
}
```

Ну а теперь можно просто вызвать нашу функцию `clearing(70)` предложив ей другой аргумент, изменив наш рассказ!

### break

Чтобы организовать бесконечный цикл, используют конструкцию `while (true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.

:::note Внимание
Если условие явно не указывать, а оставить `while ()`, то считается что условие всегда будет `true`. И тут уж приходиться из цикла выходить используя команду `break`.
:::

### continue

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву `continue` переходя к следующему шагу цикла (итерации).

:::note Обратите внимание
Если вы случайно запустите «вечную петлю», то вам придётся перезапустить браузер Chrome и исправить код, чтобы продолжить работу.
:::

Например, цикл ниже использует continue, чтобы выводить только нечётные значения:

```jsx live
function learnJavaScript() {
  let result = ''
  for (let i = 0; i < 10; i++) {
    // если true, пропустить оставшуюся часть тела цикла
    if (i % 2 == 0) continue
    result += i + ' ' // 1 3 5 7 9
  }

  return result
}
```

Для чётных значений i, директива continue прекращает выполнение тела цикла и передаёт управление на следующую итерацию for (со следующим числом). Таким образом `result += i` вызывается только для `нечётных значений`.
### Просто «так принято»

А теперь вновь напем тот же код, но назовем переменную `i`, а не `счётчик`:

```javascript
let i = 0
while (i < 10) {
  console.log(i + ' ')
  i++
}
// console.log('0 1 2 3 4 5 6 7 8 9');
```

Так, ну и в чём же тут смысл? Неужели необходима была другая переменная?

Да нет. А зачем тогда всё это? Дело в том, что в названии `i` самом по себе, конечно, ничего особенного нет, но по условленной договорённости, если хотите, по традиции, переменную, которая циклично увеличивается или уменьшается,
принято называть именно так. Когда подобного рода решения принимаются не из соображений правильности или неправильности кода, но «по традиции», мы называем это соглашением о стандартах оформления кода.

Это именно способ исполнения соглашения. Возьмём в качестве примера `верблюжийРегистр`: ведь на работе кода, по сути, никак не скажется, если ваши переменные будут ВОТТАКИМИ, или воттакими, или вовсе вот_такими. Однако, следуя соглашению об использовании `верблюжьегоРегистра` ваш код с самого начала визуально по ходил на код профессиональных разработчиков, а им самим будет гораздо легче читать и понимать его.

Так вот, использование строчной `i` для циклично увеличивающейся (при помощи `инкремента ++`) или уменьшающейся (при помощи `декремента --`) переменной — это также стандарт оформления кода. Если вы решите продолжить карьеру в качестве профессионального разработчика, то переменную i в таких обстоятельствах вам предстоит лицезреть сотни и тысячи раз.

-->
<!-- ## Цикл for...in

Проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу.

### Синтаксис

```javascript
for (variable in object) { ...
}
```

`variable` - очередное (следующее) имя свойства назначается переменной на каждой итерации.

`object` - объект, по чьим свойствам мы проходим.

### Описание

Цикл `for...in` проходит только по перечисляемым свойствам объекта. -->

<!-- ### Удаление, добавление и модификация свойств

Цикл `for...in` проходит по свойствам в произвольном порядке.

Если свойство изменяется за одну итерацию, а затем изменяется снова, его значением в цикле является его последнее значение. Свойство, удаленное до того, как до него дошёл цикл, не будет участвовать в нём.

Свойства добавленные в объекты в цикле могут быть пропущены. В общем, лучше `не добавлять, изменять или удалять` свойство из объекта `во время итерации`, если по нему ещё не прошли. Нет гарантии, что добавленное свойство будет посещено циклом, изменное после проведения изменений, а удалённое после удаления.

### Проход по массиву и for...in

Индексы массива - это перечисляемые свойства с целочисленными именами, в остальном они аналогичны свойствам объектов. Нет гарантии, что `for...in` будет возвращать индексы в конкретном порядке. Цикл `for...in` возвращает все перечисляемые свойства, включая имеющие нецелочислиненные имена и наследуемые.

:::note Замечание
`for...in` не следует использовать для `Array`, где важен порядок индексов.
:::

Так как порядок прохода зависит от реализации, `проход по массиву` может не произойти в правильном порядке. Следовательно лучше `с числовыми индексами` использовать циклы for, Array.prototype.forEach() или for...of, когда проходим по массивам, где важен `порядок доступа к свойствам`.

### Проход только через собственные свойства

Следующее выражение берёт аргументом объект. Затем проходит по всем перечислимым свойствам объекта и возвращает строку содержащую имена свойств и их значения.

Нажмите в браузере Google Chrome сочетание клавиш `Ctrl + Shift + I` и на вкладке `Console` наберите:

```javascript
var obj = { a: 1, b: 2, c: 3 }

for (var i in obj) {
  console.log('obj.' + i + ' = ' + obj[i])
}

// Выведет:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
``` -->

<!--
## Цикл for ... of

Проходит по итерируемым объектам (включающим в себя массивы, массивоподобные объекты и итераторы с генераторами), выполняя пользовательский хук с инструкциями, исполняющимися для значения каждого уникального свойства.

### Сводка

Оператор `for...of` выполняет цикл обхода итерируемых объектов (включая `Array`, `Map`, `Set`, объект аргументов и подобных), вызывая на каждом шаге итерации операторы для каждого значения из различных свойств объекта.

### Синтаксис

```javascript
for (variable of iterable) {
  statement
}
```

`Variable` - на каждом шаге итерации variable присваивается значение нового свойства объекта iterable. Переменная variable может быть также объявлена с помощью const, let или var.

`Iterable` - объект, перечисляемые свойства которого обходятся во время выполнения цикла.

### Обход Array[..]

```jsx live
function learnJavaScript() {
  let result = ''
  let mas = [10, 20, 30]

  for (let value of mas) {
    value += 5
    result += value + ' '
  }

  return result
}
```

Можно также использовать `const` вместо `let`, если не нужно переназначать переменные внутри блока.

```jsx live
function learnJavaScript() {
  let result = ''
  let mas = [10, 20, 30]

  for (const value of mas) result += value + ' '

  // 10 20 30

  return result
}
```

:::note Внимание
В цикле `for()` выполняется всего одна команда, поэтому `фигурные скобки {...}` можно не писать.
:::

### Обход String

```jsx live
function learnJavaScript() {
  let result = ''
  let iterable = 'boo'

  for (let value of iterable) {
    result += value + ' '
  }
  // "b" "o" "o"

  return result
}
``` -->

<!--
### Обход TypedArray

```jsx live
function learnJavaScript() {
  let result = ''
  let iterable = new Uint8Array([0x04, 0x10, 0xff])

  for (let value of iterable) {
    result += value + ' '
  }
  // 4 16 255
  return result
}
``` -->

<!-- ```javascript
### Обход Map
let iterable = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
])

for (let entry of iterable) {
  console.log(entry)
}
// ['a', 1] ['b', 2] ['c', 3]

for (let [key, value] of iterable) {
  console.log(value)
}
// 1 2 3
```

### Обход Set

```javascript
let iterable = new Set([1, 1, 2, 2, 3, 3])

for (let value of iterable) {
  console.log(value)
}
// 1 2 3
```

### Обход объекта arguments

```javascript
;(function () {
  for (let argument of arguments) {
    console.log(argument)
  }
})(1, 2, 3)

// 1 2 3
```

### Закрытие итераторов

В циклах `for...of` аварийный выход осуществляется через `break`, `throw` или `return`. Во всех вариантах итератор завершается.

## Различия между for...in и for...of

:::note Разница
Оба оператора, и `for...in и for...of` производят обход объектов . Разница в том, как они это делают.
:::

Для `for...in` обход перечисляемых свойств объекта осуществляется в произвольном порядке.

Для `for...of` обход происходит в соответствии с тем, какой порядок определен в итерируемом объекте. -->
